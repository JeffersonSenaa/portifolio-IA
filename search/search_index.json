{"config":{"lang":["pt"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Portf\u00f3lio de Intelig\u00eancia Artificial","text":"<p>Este reposit\u00f3rio apresenta os portf\u00f3lios desenvolvidos durante a disciplina de Intelig\u00eancia Artificial, no curso de Engenharia de Software da Universidade de Bras\u00edlia.</p> <p>Baseado nos princ\u00edpios pedag\u00f3gicos de Benigna Maria de Freitas Villas Boas (2008), este portf\u00f3lio \u00e9 uma cole\u00e7\u00e3o comentada e reflexiva de conte\u00fados, conceitos, algoritmos e an\u00e1lises voltados \u00e0 Intelig\u00eancia Artificial, elaboradas ao longo da disciplina. \u00c9 mais do que uma simples reuni\u00e3o de conte\u00fados, o portf\u00f3lio \u00e9 uma ferramenta de aprendizagem ativa, autoavalia\u00e7\u00e3o e demonstra\u00e7\u00e3o de compet\u00eancias.</p> <ul> <li> <p> Portf\u00f3lio 2</p> <p>Explora\u00e7\u00e3o de algoritmos de busca cega e informada, incluindo implementa\u00e7\u00f5es pr\u00e1ticas e an\u00e1lises de desempenho.</p> <p> Acessar</p> </li> <li> <p> Portf\u00f3lio 3</p> <p>Implementa\u00e7\u00e3o e an\u00e1lise de Problemas de Satisfa\u00e7\u00e3o de Restri\u00e7\u00f5es (CSPs) com exemplos pr\u00e1ticos e otimiza\u00e7\u00f5es.</p> <p> Acessar</p> </li> </ul>"},{"location":"#objetivos-do-portfolio","title":"Objetivos do Portf\u00f3lio","text":"<ul> <li>Demonstrar habilidades, compet\u00eancias e valores aprendidos ao longo dos estudos da disciplina;</li> <li>Refletir sobre os conte\u00fados trabalhados em sala de aula e fora dela;</li> <li>Explicar conceitos com autoria pr\u00f3pria, a partir das aulas, pesquisas e estudos individuais;</li> <li>Servir como instrumento de avalia\u00e7\u00e3o formativa pelo professor;</li> <li>Organizar produ\u00e7\u00f5es autorais, como textos, c\u00f3digos e projetos, com an\u00e1lise cr\u00edtica e contextualiza\u00e7\u00e3o.</li> </ul>"},{"location":"#estrutura-dos-topicos","title":"Estrutura dos T\u00f3picos","text":"<p>Os temas do portif\u00f3lio foram estruturados segundo os seguintes elementos:</p> <ol> <li>Introdu\u00e7\u00e3o ao Conte\u00fado </li> <li>Apresenta\u00e7\u00e3o da import\u00e2ncia do tema no contexto socioecon\u00f4mico, pol\u00edtico e tecnol\u00f3gico.</li> <li>Explora\u00e7\u00e3o e An\u00e1lise Cr\u00edtica </li> <li>Organiza\u00e7\u00e3o dos conceitos, com materiais pesquisados, referenciados e comentados.</li> <li>Problemas, Projetos e Aplica\u00e7\u00f5es </li> <li>Proposi\u00e7\u00e3o de exerc\u00edcios, problemas ou projetos autorais com solu\u00e7\u00f5es desenvolvidas e comentadas.</li> <li>Conclus\u00e3o </li> <li>Reflex\u00e3o sobre vantagens, limita\u00e7\u00f5es e principais aprendizados do t\u00f3pico.</li> </ol>"},{"location":"#capitulos-do-portifolio","title":"Cap\u00edtulos do Portif\u00f3lio","text":"<ol> <li>Introdu\u00e7\u00e3o \u00e0 Intelig\u00eancia Artificial</li> <li>Hist\u00f3rico, estado da arte, benef\u00edcios, riscos, agentes inteligentes, ambientes e racionalidade.</li> <li>Resolu\u00e7\u00e3o de Problemas por Busca</li> <li>Busca cega, informada e em ambientes complexos com algoritmos implementados em Python.</li> <li>Problemas de Satisfa\u00e7\u00e3o de Restri\u00e7\u00f5es</li> <li>Modelagem e resolu\u00e7\u00e3o de CSPs (Constraint Satisfaction Problems).</li> <li>Agentes L\u00f3gicos</li> <li>Representa\u00e7\u00e3o do conhecimento e infer\u00eancia por meio da l\u00f3gica proposicional e de predicados.</li> <li>Incerteza e Redes Bayesianas</li> <li>Probabilidade, infer\u00eancia bayesiana, filtros de Kalman e racioc\u00ednio probabil\u00edstico ao longo do tempo.</li> <li>Aprendizado de M\u00e1quina</li> <li>Fundamentos do aprendizado supervisionado, n\u00e3o supervisionado e suas aplica\u00e7\u00f5es pr\u00e1ticas.</li> </ol>"},{"location":"#tecnologias-e-ferramentas-utilizadas","title":"Tecnologias e Ferramentas Utilizadas","text":"<ul> <li>Python \u2013 Implementa\u00e7\u00e3o dos algoritmos</li> <li>MkDocs \u2013 Estrutura e navega\u00e7\u00e3o do portf\u00f3lio</li> <li>MkDocs Material \u2013 Tema visual moderno</li> </ul>"},{"location":"#formato-de-apresentacao","title":"Formato de Apresenta\u00e7\u00e3o","text":"<p>Este portf\u00f3lio utiliza o formato de relat\u00f3rio estruturado com navega\u00e7\u00e3o digital, utilizando o MkDocs. Outras formas, como fichamento, mapa mental ou v\u00eddeo, poder\u00e3o ser adicionadas conforme a necessidade.</p> <p>Todos os materiais s\u00e3o referenciados e comentados, em conformidade com os crit\u00e9rios de avalia\u00e7\u00e3o da disciplina.</p>"},{"location":"#autor-jefferson-sena","title":"Autor: Jefferson Sena","text":"<ul> <li> GitHub</li> <li> LinkedIn</li> </ul> <p>Estudante de Engenharia de Software - Universidade de Bras\u00edlia (UnB) Reposit\u00f3rio acad\u00eamico desenvolvido para a disciplina de Intelig\u00eancia Artificial  </p>"},{"location":"#licenca","title":"Licen\u00e7a","text":"<p>Este material \u00e9 disponibilizado sob a Licen\u00e7a MIT. Uso educacional incentivado.</p> <p>\u201cO portf\u00f3lio \u00e9 um instrumento de avalia\u00e7\u00e3o e reflex\u00e3o que permite que o estudante se reconhe\u00e7a em sua pr\u00f3pria trajet\u00f3ria de aprendizagem.\u201d \u2014 Benigna Maria de Freitas Villas Boas (2008)</p> <p> </p>"},{"location":"portifolio-2/","title":"Portifolio 2","text":""},{"location":"portifolio-2/#algoritmo-de-busca-cega","title":"Algoritmo de busca cega;","text":""},{"location":"portifolio-2/#random-search","title":"Random Search","text":"Python<pre><code>import random\ndef random_search(goal, domain):\nattempts = 0\nwhile True:\nguess = random.choice(domain)\nattempts += 1\nif guess == goal:\nreturn guess, attempts\n</code></pre>"},{"location":"portifolio-2/#o-que-sao-algoritmos-de-busca-cega","title":"O que s\u00e3o Algoritmos de Busca Cega?","text":"<p>Algoritmos de busca cega (ou busca n\u00e3o informada) s\u00e3o algoritmos que n\u00e3o utilizam nenhuma informa\u00e7\u00e3o adicional sobre o problema, como dist\u00e2ncia ou estimativas at\u00e9 o objetivo. Eles exploram o espa\u00e7o de busca de forma sistem\u00e1tica e completa, sem levar em considera\u00e7\u00e3o a posi\u00e7\u00e3o da meta, sendo ent\u00e3o \u201ccegos\u201d quanto ao melhor caminho.</p>"},{"location":"portifolio-2/#origem","title":"Origem","text":"<ul> <li>Surgiram nos anos 1950-60, envolto aos primeiros trabalhos em Intelig\u00eancia Artificial simb\u00f3lica.</li> <li>Aplicados em resolu\u00e7\u00e3o autom\u00e1tica de problemas, como quebra-cabe\u00e7as, jogos simples e sistemas de infer\u00eancia l\u00f3gica.</li> <li>S\u00e3o os primeiros tipos de algoritmos de busca utilizados em IA, tendo ra\u00edzes na teoria de grafos e na teoria dos aut\u00f4matos.</li> </ul>"},{"location":"portifolio-2/#como-funcionam","title":"Como Funcionam?","text":"<p>Eles expandem os n\u00f3s do espa\u00e7o de estados de acordo com uma regra fixa, como:</p> <ul> <li>Em ordem de chegada (fila \u2013 busca em largura).</li> <li>Em ordem de profundidade (pilha \u2013 busca em profundidade).</li> <li>Com menor custo acumulado (busca de custo uniforme).</li> </ul> <p>Esses algoritmos, n\u00e3o sabem se est\u00e3o se aproximando da meta. Apenas tentam todos os caminhos poss\u00edveis dentro do contexto.</p>"},{"location":"portifolio-2/#contextos-de-aplicacao","title":"Contextos de Aplica\u00e7\u00e3o","text":"<p>Embora menos eficientes que os algoritmos informados, os algoritmos de busca cega ainda s\u00e3o \u00fateis quando:</p> <ul> <li>N\u00e3o h\u00e1 informa\u00e7\u00e3o heur\u00edstica confi\u00e1vel dispon\u00edvel.</li> <li>O espa\u00e7o de busca \u00e9 pequeno.</li> <li>\u00c9 necess\u00e1rio garantir que a solu\u00e7\u00e3o seja \u00f3tima ou completa, mesmo sem pistas.</li> </ul> <p>Exemplos de aplica\u00e7\u00f5es:</p> <ul> <li>Solu\u00e7\u00f5es para problemas cl\u00e1ssicos de IA como o problema das torres de Han\u00f3i, quebra-cabe\u00e7as 8-puzzle.</li> <li>Sistemas educacionais, para ensinar l\u00f3gica de busca.</li> <li>Diagn\u00f3stico automatizado onde a heur\u00edstica n\u00e3o \u00e9 clara.</li> <li>Planejamento de a\u00e7\u00f5es simples em jogos e agentes aut\u00f4nomos.</li> </ul>"},{"location":"portifolio-2/#importancia","title":"Import\u00e2ncia","text":"<ul> <li>S\u00e3o a base conceitual para algoritmos mais avan\u00e7ados.</li> <li>Garantem completude (encontram a solu\u00e7\u00e3o, se houver uma).</li> <li>Podem ser usados em qualquer tipo de problema, mesmo sem conhecimento do dom\u00ednio.</li> <li>S\u00e3o \u00fateis para compara\u00e7\u00e3o e benchmarking de novos algoritmos.</li> </ul>"},{"location":"portifolio-2/#1-busca-exaustiva-brute-force-search","title":"1. Busca Exaustiva (Brute-force Search)","text":"<ul> <li>Verifica todas as combina\u00e7\u00f5es poss\u00edveis at\u00e9 encontrar a solu\u00e7\u00e3o.</li> <li>Muito lento, mas simples e confi\u00e1vel.</li> <li>Usado quando o espa\u00e7o de busca \u00e9 pequeno ou para validar solu\u00e7\u00f5es.</li> </ul> Text Only<pre><code>def brute_force_search(problem):\n    for solution in problem.all_possible_solutions():\n        if problem.is_goal(solution):\n            return solution\n    return None\n#Aplicacao: Tentar todas as senhas poss\u00edveis de um cadeado.\n</code></pre>"},{"location":"portifolio-2/#2-backtracking","title":"2. Backtracking","text":"<ul> <li>T\u00e9cnica de busca recursiva que volta atr\u00e1s quando encontra um beco sem sa\u00edda.</li> <li>Muito usada em problemas de combina\u00e7\u00e3o e permuta\u00e7\u00e3o, como Sudoku e quebra-cabe\u00e7as.</li> </ul> Python<pre><code>def solve(problem, state):\n    if problem.is_goal(state):\n        return state\n    for move in problem.legal_moves(state):\n        next_state = problem.apply_move(state, move)\n        result = solve(problem, next_state)\n        if result:\n            return result\n    return None\n#Aplicacao: Resolver o Sudoku ou labirintos.\n</code></pre>"},{"location":"portifolio-2/#3-iterative-deepening-search-ids","title":"3. Iterative Deepening Search (IDS)","text":"<ul> <li>Combina\u00e7\u00e3o de profundidade com garantia de completude.</li> <li>Executa v\u00e1rias buscas em profundidade com profundidade limitada que vai aumentando.</li> <li>Usa pouca mem\u00f3ria encontrando solu\u00e7\u00f5es \u00f3timas.</li> </ul>"},{"location":"portifolio-2/#aplicacao-sudoku-com-backtracking","title":"Aplica\u00e7\u00e3o: Sudoku com Backtracking","text":"<p>Imagine que voc\u00ea est\u00e1 resolvendo um Sudoku. Voc\u00ea n\u00e3o sabe qual n\u00famero colocar, ent\u00e3o tenta todos de 1 a 9 em uma c\u00e9lula vazia. Caso d\u00ea erro, voc\u00ea volta atr\u00e1s e tenta outro n\u00famero \u2014 esse \u00e9 o comportamento t\u00edpico da busca cega com backtracking.</p>"},{"location":"portifolio-2/#algoritmo-de-busca-informada","title":"Algoritmo de busca informada;","text":""},{"location":"portifolio-2/#algoritmo-de-simulated-annealing","title":"Algoritmo de Simulated Annealing","text":"Python<pre><code>import math\nimport random\n\ndef simulated_annealing(objective_function, domain, temp_initial, cooling_rate):\n    current = random.uniform(*domain)\n    temp = temp_initial\n\n    while temp &gt; 1:\n        neighbor = current + random.uniform(-1, 1)\n        neighbor = max(min(neighbor, domain[1]), domain[0])\n        cost_diff = objective_function(neighbor) - objective_function(current)\n\n        if cost_diff &lt; 0 or math.exp(-cost_diff / temp) &gt; random.random():\n            current = neighbor\n\n        temp *= cooling_rate\n\n    return current\n\n# Exemplo: minimizar a fun\u00e7\u00e3o f(x) = x^2\nresult = simulated_annealing(lambda x: x**2, domain=(-10, 10), temp_initial=100, cooling_rate=0.95)\nprint(f\"Solu\u00e7\u00e3o encontrada: {result}, f(x) = {result**2}\")\n#**Aplica\u00e7\u00e3o:** Otimizar de forma cont\u00ednua as fun\u00e7\u00f5es complexas com m\u00ednimos locais.\n</code></pre>"},{"location":"portifolio-2/#o-que-sao-algoritmos-de-busca-informada","title":"O que s\u00e3o Algoritmos de Busca Informada?","text":"<p>Algoritmos de busca informada, s\u00e3o algoritmos que utilizam informa\u00e7\u00f5es adicionais (heur\u00edsticas) sobre o problema para a tomada de decis\u00f5es mais inteligentes durante a busca por solu\u00e7\u00f5es. Tendem a ser mais eficientes do que algoritmos de busca cega (como BFS ou DFS) porque conseguem priorizar caminhos promissores e assim evitar explorar caminhos irrelevantes.</p>"},{"location":"portifolio-2/#origem_1","title":"Origem","text":"<ul> <li>Deriva\u00e7\u00f5es de pesquisas em ci\u00eancia da computa\u00e7\u00e3o e IA cl\u00e1ssica nas d\u00e9cadas de 1960 e 1970.</li> <li>Fortemente influenciados pelo trabalho de nomes como Alan Turing, John McCarthy e Marvin Minsky.</li> <li>Cresceram com os primeiros sistemas de planejamento autom\u00e1tico e resolu\u00e7\u00e3o de problemas em ambientes como jogos e sistemas especialistas.</li> </ul>"},{"location":"portifolio-2/#como-funcionam_1","title":"Como Funcionam?","text":"<p>Esses algoritmos usam uma fun\u00e7\u00e3o heur\u00edstica <code>h(n)</code> que estima o custo restante de um estado <code>n</code> at\u00e9 a solu\u00e7\u00e3o. Essa fun\u00e7\u00e3o:</p> <ul> <li>N\u00e3o precisa ser perfeita, apenas uma boa estimativa.</li> <li>Ajuda a escolher qual n\u00f3 explorar primeiro com base em qual parece mais promissor.</li> </ul>"},{"location":"portifolio-2/#contextos-de-aplicacao_1","title":"Contextos de Aplica\u00e7\u00e3o","text":"<ul> <li>Jogos de estrat\u00e9gia e tabuleiro (ex.: xadrez, damas, sudoku)</li> <li>Planejamento de rotas (ex.: GPS, log\u00edstica)</li> <li>Rob\u00f3tica (ex.: navega\u00e7\u00e3o de rob\u00f4s aut\u00f4nomos)</li> <li>Diagn\u00f3stico autom\u00e1tico e sistemas especialistas</li> <li>Solu\u00e7\u00f5es em tempo real para IA em videogames</li> <li>Assistentes de voz e NLP (em fases de planejamento de di\u00e1logo)</li> </ul>"},{"location":"portifolio-2/#importancia_1","title":"Import\u00e2ncia","text":"<ul> <li>Efici\u00eancia: Exploram menos n\u00f3s que as buscas cegas.</li> <li>Escalabilidade: Lidam melhor com espa\u00e7os de busca grandes.</li> <li>Adaptabilidade: A heur\u00edstica pode ser ajustada para diferentes dom\u00ednios.</li> <li>S\u00e3o a base para algoritmos como A, IDA, Beam Search e etc.</li> </ul>"},{"location":"portifolio-2/#exemplos-de-algoritmos-de-busca-informada","title":"Exemplos de Algoritmos de Busca Informada","text":""},{"location":"portifolio-2/#1-beam-search","title":"1. Beam Search","text":"<ul> <li>Explora apenas os <code>k</code> melhores caminhos em cada n\u00edvel da \u00e1rvore de busca, limitando o n\u00famero de n\u00f3s expandidos.</li> <li>Usado em NLP (ex: tradu\u00e7\u00e3o autom\u00e1tica), pois \u00e9 mais eficiente do que expandir todos os caminhos poss\u00edveis.</li> </ul> Python<pre><code>import heapq\n\ndef beam_search(start, goal, neighbors, heuristic, beam_width):\n    beam = [(heuristic(start, goal), start)]\n    while beam:\n        new_beam = []\n        for _, node in beam:\n            if node == goal:\n                return node\n            for neighbor in neighbors(node):\n                cost = heuristic(neighbor, goal)\n                heapq.heappush(new_beam, (cost, neighbor))\n        beam = heapq.nsmallest(beam_width, new_beam)\n    return None\n</code></pre>"},{"location":"portifolio-2/#2-iterative-deepening-a-ida","title":"2. Iterative Deepening A (IDA)","text":"<ul> <li>Combina a busca em profundidade com heur\u00edsticas.</li> <li>Utiliza limites crescentes baseados na fun\u00e7\u00e3o <code>f(n) = g(n) + h(n)</code>.</li> </ul>"},{"location":"portifolio-2/#3-weighted-a","title":"3. Weighted A*","text":"<ul> <li>Variante do A*, mas multiplica a heur\u00edstica por um fator <code>w</code>:<ul> <li><code>f(n) = g(n) + w * h(n)</code></li> </ul> </li> <li>Com <code>w &gt; 1</code>, torna-se mais r\u00e1pido, mas menos preciso.</li> <li>Usado quando o tempo \u00e9 mais importante que a perfei\u00e7\u00e3o (ex: jogos ou rob\u00f4s em tempo real).</li> </ul>"},{"location":"portifolio-2/#exemplo-de-aplicacao-planejamento-de-rota-com-beam-search","title":"Exemplo de Aplica\u00e7\u00e3o: Planejamento de Rota com Beam Search","text":"<p>Imagine um rob\u00f4 de limpeza que decida o caminho mais eficiente at\u00e9 um ponto para recarregar. O mapa da casa \u00e9 representado como um grafo. O algoritmo usa a dist\u00e2ncia euclidiana como heur\u00edstica decidindo quais caminhos explorar primeiro, evitando paredes e obst\u00e1culos.</p>"},{"location":"portifolio-2/#algoritmo-de-busca-em-ambientes-complexos-gradient-descent-ou-hill-climbing","title":"Algoritmo de busca em ambientes complexos (Gradient Descent ou Hill Climbing)","text":""},{"location":"portifolio-2/#ambiente-complexo-algoritmo-de-gradiente-descendente","title":"Ambiente Complexo \u2014 Algoritmo de Gradiente Descendente","text":"Python<pre><code>def gradient_descent(derivative_func, start, learning_rate, n_iterations):\n    x = start\n    for _ in range(n_iterations):\n        grad = derivative_func(x)\n        x = x - learning_rate * grad\n    return x\n\n# Exemplo: minimizar f(x) = x^2 \u2192 f'(x) = 2x\nminimum = gradient_descent(lambda x: 2*x, start=10.0, learning_rate=0.1, n_iterations=100)\nprint(f\"M\u00ednimo encontrado: x = {minimum}, f(x) = {minimum**2}\")\n</code></pre>"},{"location":"portifolio-2/#o-que-sao-algoritmos-de-busca-em-ambientes-complexos","title":"O que s\u00e3o Algoritmos de Busca em Ambientes Complexos?","text":"<p>S\u00e3o algoritmos usados quando o espa\u00e7o de busca \u00e9 muito grande, cont\u00ednuo ou din\u00e2mico, o que torna invi\u00e1vel testar todas as solu\u00e7\u00f5es poss\u00edveis. Eles buscam melhorar uma solu\u00e7\u00e3o progressivamente, explorando os arredores de uma solu\u00e7\u00e3o atual com base em algum crit\u00e9rio de melhoria.</p>"},{"location":"portifolio-2/#principais-tipos","title":"Principais Tipos","text":""},{"location":"portifolio-2/#1-gradient-descent-descida-do-gradiente","title":"1. Gradient Descent (Descida do Gradiente)","text":"<ul> <li>Tipo: Algoritmo de otimiza\u00e7\u00e3o cont\u00ednua.</li> <li>Utiliza\u00e7\u00e3o: A fun\u00e7\u00e3o objetivo \u00e9 diferenci\u00e1vel (ou seja, podemos calcular sua derivada).</li> <li>Ideia: Dado um ponto inicial, move-se na dire\u00e7\u00e3o do gradiente negativo da fun\u00e7\u00e3o, que \u00e9 a dire\u00e7\u00e3o de maior \"decl\u00ednio\" da fun\u00e7\u00e3o.</li> </ul>"},{"location":"portifolio-2/#como-funciona","title":"Como funciona:","text":"<ol> <li>Escolhe-se uma solu\u00e7\u00e3o inicial (ex: peso de um modelo).</li> <li>Calcula-se o gradiente (a inclina\u00e7\u00e3o) da fun\u00e7\u00e3o no ponto atual.</li> <li>Move-se na dire\u00e7\u00e3o oposta ao gradiente.</li> <li>Repete-se o processo at\u00e9 atingir um m\u00ednimo local ou global.</li> </ol>"},{"location":"portifolio-2/#formula-basica-x-x-fx","title":"F\u00f3rmula b\u00e1sica:   x = x - \u03b1 * \u2207f(x)","text":""},{"location":"portifolio-2/#2-busca-local-hill-climbing-simulated-annealing-etc","title":"2. Busca Local (Hill Climbing, Simulated Annealing, etc.)","text":"<ul> <li>Tipo: Heur\u00edsticas de otimiza\u00e7\u00e3o baseadas em melhorar uma solu\u00e7\u00e3o atual.</li> <li>Diferente do Gradient Descent: N\u00e3o depende de derivadas, funciona com fun\u00e7\u00f5es n\u00e3o cont\u00ednuas.</li> <li>Exemplo relevante: Simulated Annealing, que permite aceitar piores solu\u00e7\u00f5es com alguma probabilidade para escapar de m\u00ednimos locais.</li> </ul>"},{"location":"portifolio-2/#origem-e-contexto-historico","title":"Origem e Contexto Hist\u00f3rico","text":"<ul> <li>O Gradient Descent surgiu no contexto do c\u00e1lculo multivariado e foi adaptado para problemas de IA a partir da d\u00e9cada de 1950.</li> <li>Tornou-se extremamente popular na aprendizagem de m\u00e1quina com o surgimento das redes neurais.</li> <li>M\u00e9todos de busca local t\u00eam origem em t\u00e9cnicas de otimiza\u00e7\u00e3o cl\u00e1ssica, mas evolu\u00edram para lidar com problemas n\u00e3o determin\u00edsticos e estoc\u00e1sticos em IA.</li> </ul>"},{"location":"portifolio-2/#aplicacoes-na-inteligencia-artificial","title":"Aplica\u00e7\u00f5es na Intelig\u00eancia Artificial","text":""},{"location":"portifolio-2/#gradient-descent","title":"Gradient Descent:","text":"<ul> <li>Aprendizado de m\u00e1quina: Treinamento de redes neurais profundas, regress\u00e3o log\u00edstica, SVM, etc.</li> <li>Redu\u00e7\u00e3o de erro: Minimiza uma fun\u00e7\u00e3o de custo, como erro quadr\u00e1tico m\u00e9dio (MSE).</li> <li>Modelos probabil\u00edsticos: Ajuste de par\u00e2metros em modelos como Naive Bayes ou HMM.</li> </ul>"},{"location":"portifolio-2/#outros-algoritmos-de-busca-local","title":"Outros algoritmos de busca local:","text":"<ul> <li>Otimiza\u00e7\u00e3o de hiperpar\u00e2metros (ex: n\u00famero de neur\u00f4nios, taxa de aprendizado).</li> <li>Planejamento de a\u00e7\u00f5es em IA (com Simulated Annealing ou algoritmos estoc\u00e1sticos).</li> <li>IA em jogos e rob\u00f3tica, onde o ambiente muda e n\u00e3o h\u00e1 tempo para uma busca exaustiva.</li> </ul>"},{"location":"portifolio-2/#exemplos-de-algoritmos","title":"Exemplos de Algoritmos","text":""},{"location":"portifolio-2/#1-gradient-descent","title":"1. Gradient Descent","text":"Python<pre><code># Minimizar a fun\u00e7\u00e3o f(x) = (x - 5)**2\ndef f(x):\n    return (x - 5)**2\n\ndef grad_f(x):\n    return 2 * (x - 5)\n\nx = 0  # ponto inicial\nlr = 0.1  # taxa de aprendizado\n\nfor _ in range(100):\n    x -= lr * grad_f(x)\n\nprint(f\"M\u00ednimo encontrado em x = {x}\")\n#Converge para x = 5, que \u00e9 o m\u00ednimo global da fun\u00e7\u00e3o.\n</code></pre>"},{"location":"portifolio-2/#2-simulated-annealing-busca-local-com-perturbacoes","title":"2. Simulated Annealing (busca local com perturba\u00e7\u00f5es)","text":"Python<pre><code>import math\nimport random\n\ndef objective(x):\n    return (x - 3)**2 + 2\n\nx = random.uniform(-10, 10)\nT = 1.0\nT_min = 0.0001\nalpha = 0.9\n\nwhile T &gt; T_min:\n    new_x = x + random.uniform(-1, 1)\n    delta = objective(new_x) - objective(x)\n    if delta &lt; 0 or random.random() &lt; math.exp(-delta / T):\n        x = new_x\n    T *= alpha\n\nprint(f\"Melhor solu\u00e7\u00e3o encontrada: x = {x}\")\n</code></pre>"},{"location":"portifolio-2/#importancia-dos-algoritmos-em-ambientes-complexos","title":"Import\u00e2ncia dos Algoritmos em Ambientes Complexos","text":"<ul> <li>S\u00e3o fundamentais para resolver problemas onde:<ul> <li>O espa\u00e7o de busca \u00e9 enorme ou cont\u00ednuo.</li> <li>A solu\u00e7\u00e3o exata n\u00e3o \u00e9 conhecida.</li> <li>\u00c9 necess\u00e1rio tempo real ou adapta\u00e7\u00e3o constante (ex: IA em jogos, carros aut\u00f4nomos).</li> </ul> </li> <li>Est\u00e3o na base de muitos avan\u00e7os modernos em deep learning e intelig\u00eancia artificial.</li> </ul> Conceito Gradient Descent Busca Local Precisa de derivada? Sim N\u00e3o Tipo de fun\u00e7\u00e3o Cont\u00ednua Arbitr\u00e1ria Exemplo Treinamento de rede neural Planejamento em IA Vantagem Converg\u00eancia r\u00e1pida Vers\u00e1til para ambientes estoc\u00e1sticos"},{"location":"portifolio-2/#algoritmo-genetico","title":"Algoritmo gen\u00e9tico","text":"Python<pre><code>import random\n\ndef fitness(x):\n    return -1 * (x - 3)**2 + 9  # M\u00e1ximo em x = 3\n\ndef genetic_algorithm(population, generations, mutation_rate=0.1):\n    for _ in range(generations):\n        population.sort(key=fitness, reverse=True)\n        next_gen = population[:2]  # elitismo\n\n        while len(next_gen) &lt; len(population):\n            p1, p2 = random.sample(population[:4], 2)\n            child = (p1 + p2) / 2\n            if random.random() &lt; mutation_rate:\n                child += random.uniform(-1, 1)\n            next_gen.append(child)\n\n        population = next_gen\n\n    best = max(population, key=fitness)\n    return best\n\n# Exemplo: encontrar o m\u00e1ximo da fun\u00e7\u00e3o - (x-3)^2 + 9\ninitial_pop = [random.uniform(0, 6) for _ in range(6)]\nsolution = genetic_algorithm(initial_pop, generations=20)\nprint(f\"Solu\u00e7\u00e3o gen\u00e9tica: x = {solution}, f(x) = {fitness(solution)}\")\n</code></pre>"},{"location":"portifolio-2/#o-que-sao-algoritmos-geneticos","title":"O que s\u00e3o Algoritmos Gen\u00e9ticos?","text":"<p>Algoritmos Gen\u00e9ticos (AGs) s\u00e3o t\u00e9cnicas de otimiza\u00e7\u00e3o e busca inspiradas nos processos de sele\u00e7\u00e3o natural e evolu\u00e7\u00e3o biol\u00f3gica descritos por Charles Darwin. Eles pertencem \u00e0 categoria de algoritmos evolutivos, que usam conceitos como popula\u00e7\u00e3o, muta\u00e7\u00e3o, reprodu\u00e7\u00e3o e sele\u00e7\u00e3o para resolver problemas complexos.</p>"},{"location":"portifolio-2/#origem-dos-algoritmos-geneticos","title":"Origem dos Algoritmos Gen\u00e9ticos","text":"<ul> <li>Foram propostos por John Holland na d\u00e9cada de 1970, na Universidade de Michigan.</li> <li>Holland criou uma estrutura matem\u00e1tica para entender os mecanismos da evolu\u00e7\u00e3o natural e adapt\u00e1-los \u00e0 resolu\u00e7\u00e3o de problemas computacionais.</li> <li>Seu livro de 1975, \"Adaptation in Natural and Artificial Systems\", \u00e9 a base te\u00f3rica dos AGs.</li> </ul>"},{"location":"portifolio-2/#como-funcionam-os-algoritmos-geneticos","title":"Como Funcionam os Algoritmos Gen\u00e9ticos?","text":"<ol> <li>Inicializa\u00e7\u00e3o: Uma popula\u00e7\u00e3o inicial de solu\u00e7\u00f5es (chamadas de indiv\u00edduos ou cromossomos) \u00e9 gerada aleatoriamente.</li> <li>Avalia\u00e7\u00e3o (Fitness): Cada indiv\u00edduo \u00e9 avaliado por uma fun\u00e7\u00e3o de aptid\u00e3o (fitness function) que mede qu\u00e3o boa \u00e9 a solu\u00e7\u00e3o.</li> <li>Sele\u00e7\u00e3o: Indiv\u00edduos mais aptos t\u00eam mais chances de serem escolhidos para gerar descendentes.</li> <li>Crossover (Recombina\u00e7\u00e3o): Partes dos cromossomos dos pais s\u00e3o combinadas para criar novos indiv\u00edduos.</li> <li>Muta\u00e7\u00e3o: Pequenas altera\u00e7\u00f5es aleat\u00f3rias s\u00e3o feitas nos descendentes para manter diversidade gen\u00e9tica.</li> <li>Substitui\u00e7\u00e3o: Uma nova gera\u00e7\u00e3o substitui (total ou parcialmente) a antiga.</li> <li>Itera\u00e7\u00e3o: O processo se repete por v\u00e1rias gera\u00e7\u00f5es at\u00e9 que uma condi\u00e7\u00e3o de parada seja satisfeita (ex: n\u00famero m\u00e1ximo de gera\u00e7\u00f5es, solu\u00e7\u00e3o suficientemente boa, etc).</li> </ol>"},{"location":"portifolio-2/#contextos-de-aplicacao-dos-algoritmos-geneticos","title":"Contextos de Aplica\u00e7\u00e3o dos Algoritmos Gen\u00e9ticos","text":"<p>AGs s\u00e3o usados em problemas de otimiza\u00e7\u00e3o complexos, onde n\u00e3o h\u00e1 uma solu\u00e7\u00e3o exata vi\u00e1vel ou onde o espa\u00e7o de busca \u00e9 muito grande:</p>"},{"location":"portifolio-2/#exemplos-de-aplicacoes","title":"Exemplos de aplica\u00e7\u00f5es:","text":"<ul> <li>Otimiza\u00e7\u00e3o de rotas: problema do caixeiro viajante (TSP), roteamento de entregas.</li> <li>Agendamento: aloca\u00e7\u00e3o de tarefas em f\u00e1bricas ou escalas de funcion\u00e1rios.</li> <li>Design de redes neurais: otimiza\u00e7\u00e3o de hiperpar\u00e2metros de redes profundas.</li> <li>Engenharia: design de circuitos eletr\u00f4nicos, estruturas mec\u00e2nicas.</li> <li>Bioinform\u00e1tica: alinhamento de sequ\u00eancias gen\u00e9ticas, previs\u00e3o de estrutura de prote\u00ednas.</li> <li>Criptografia: quebra de cifras por tentativa evolutiva.</li> <li>Jogos e IA: criar NPCs adaptativos ou estrat\u00e9gias vencedoras.</li> </ul>"},{"location":"portifolio-2/#por-que-algoritmos-geneticos-sao-importantes","title":"Por que Algoritmos Gen\u00e9ticos s\u00e3o Importantes?","text":"<ul> <li>Robustez: Funcionam bem mesmo com fun\u00e7\u00f5es de custo n\u00e3o lineares, descont\u00ednuas ou com m\u00faltiplos \u00f3timos locais.</li> <li>Paralelismo natural: Por usar popula\u00e7\u00f5es, podem explorar v\u00e1rias solu\u00e7\u00f5es ao mesmo tempo.</li> <li>Generalidade: Podem ser aplicados a muitos tipos diferentes de problemas.</li> <li>N\u00e3o precisam de derivadas: Diferente do gradiente descendente, AGs n\u00e3o exigem fun\u00e7\u00f5es diferenci\u00e1veis.</li> </ul>"},{"location":"portifolio-2/#exemplos-de-algoritmos-geneticos-e-variantes","title":"Exemplos de Algoritmos Gen\u00e9ticos e Variantes","text":"<ol> <li>Algoritmo Gen\u00e9tico Cl\u00e1ssico (GA):<ul> <li>Baseado nos operadores b\u00e1sicos: sele\u00e7\u00e3o, crossover e muta\u00e7\u00e3o.</li> </ul> </li> <li>Algoritmo Gen\u00e9tico com Elitismo:<ul> <li>Garante que os melhores indiv\u00edduos de uma gera\u00e7\u00e3o sobrevivem \u00e0 pr\u00f3xima.</li> </ul> </li> <li>Algoritmos Gen\u00e9ticos Multiobjetivo (ex: NSGA-II):<ul> <li>Resolvem problemas com m\u00faltiplos crit\u00e9rios de otimiza\u00e7\u00e3o.</li> </ul> </li> <li>Algoritmos Evolutivos Diferenciais:<ul> <li>Variante que usa diferen\u00e7as entre solu\u00e7\u00f5es para gerar novas.</li> </ul> </li> <li>Algoritmos Gen\u00e9ticos com Codifica\u00e7\u00e3o Real:<ul> <li>Ao inv\u00e9s de bits, usam n\u00fameros reais (mais comum em otimiza\u00e7\u00e3o cont\u00ednua).</li> </ul> </li> </ol>"},{"location":"portifolio-2/#referencias","title":"Refer\u00eancias","text":"<ul> <li>RUSSELL, Stuart J.; NORVIG, Peter. Intelig\u00eancia Artificial. 3. ed. Rio de Janeiro: Elsevier, 2013.   (T\u00edtulo original: Artificial Intelligence: A Modern Approach)</li> <li>LUGER, George F. Intelig\u00eancia Artificial: estruturas e estrat\u00e9gias para a resolu\u00e7\u00e3o de problemas complexos. 6. ed. Pearson, 2009.</li> <li>GOLDBERG, David E. Algoritmos Gen\u00e9ticos em Busca, Otimiza\u00e7\u00e3o e Aprendizado de M\u00e1quina. Pearson Education, 1989.</li> <li>HOLLAND, John H. Adaptation in Natural and Artificial Systems. MIT Press, 1992.</li> <li>MITCHELL, Melanie. An Introduction to Genetic Algorithms. MIT Press, 1996.</li> <li>GOODFELLOW, Ian; BENGIO, Yoshua; COURVILLE, Aaron. Deep Learning. MIT Press, 2016. Dispon\u00edvel em: https://www.deeplearningbook.org/</li> <li>HASTIE, Trevor; TIBSHIRANI, Robert; FRIEDMAN, Jerome. The Elements of Statistical Learning. Springer, 2009.</li> <li>OpenAI Blog \u2013 AI concepts and research: https://openai.com/research</li> <li>Towards Data Science \u2013 Medium Publication: https://towardsdatascience.com/</li> <li>Geeks for Geeks \u2013 AI/ML tutorials: https://www.geeksforgeeks.org/fundamentals-of-artificial-intelligence/</li> <li>Stanford University \u2013 AI Course Materials: https://cs221.stanford.edu/</li> </ul>"},{"location":"portifolio-3/","title":"Portf\u00f3lio 3 - Constraint Satisfaction Problems - CSP","text":""},{"location":"portifolio-3/#introducao-aos-csps","title":"Introdu\u00e7\u00e3o aos CSPs","text":"<p>Problemas de Satisfa\u00e7\u00e3o de Restri\u00e7\u00f5es (CSPs), trata-se de uma classe de problemas onde o objetivo \u00e9 encontrar valores para um conjunto de vari\u00e1veis que satisfa um conjunto de restri\u00e7\u00f5es. Formalmente, um CSP consiste em:</p> <ul> <li>Um conjunto de vari\u00e1veis X = {X\u2081, X\u2082, ..., X\u2099}</li> <li>Um conjunto de dom\u00ednios D = {D\u2081, D\u2082, ..., D\u2099}, onde cada D\u1d62 \u00e9 o conjunto de valores poss\u00edveis para X\u1d62</li> <li>Um conjunto de restri\u00e7\u00f5es C = {C\u2081, C\u2082, ..., C\u2098} que especificam combina\u00e7\u00f5es v\u00e1lidas de valores</li> </ul>"},{"location":"portifolio-3/#11-exemplo-pratico-solucionador-de-sudoku-simples-usando-csp","title":"1.1 Exemplo Pr\u00e1tico: Solucionador de Sudoku Simples usando CSP","text":"<p>Neste exemplo, implemento um solucionador de Sudoku utilizando t\u00e9cnicas de CSP.</p> <ul> <li>Vari\u00e1veis: 81 c\u00e9lulas do tabuleiro (9x9)</li> <li>Dom\u00ednios: N\u00fameros de 1 a 9 para cada c\u00e9lula</li> <li>Restri\u00e7\u00f5es: </li> <li>Cada linha cont\u00e9m n\u00fameros \u00fanicos de 1 a 9</li> <li>Cada coluna cont\u00e9m n\u00fameros \u00fanicos de 1 a 9</li> <li>Cada subgrade 3x3 cont\u00e9m n\u00fameros \u00fanicos de 1 a 9</li> </ul> Python<pre><code>class SudokuCSP:\n    def __init__(self, board):\n        self.board = board\n        self.variables = [(i, j) for i in range(9) for j in range(9)]\n        self.domains = {var: set(range(1, 10)) for var in self.variables}\n        self.constraints = self._get_constraints()\n\n    def _get_constraints(self):\n        constraints = []\n        # Restri\u00e7\u00f5es de linha\n        for i in range(9):\n            for j in range(9):\n                for k in range(j + 1, 9):\n                    constraints.append(((i, j), (i, k)))\n\n        # Restri\u00e7\u00f5es de coluna\n        for j in range(9):\n            for i in range(9):\n                for k in range(i + 1, 9):\n                    constraints.append(((i, j), (k, j)))\n\n        # Restri\u00e7\u00f5es de subgrade 3x3\n        for block_i in range(3):\n            for block_j in range(3):\n                cells = [(3*block_i + i, 3*block_j + j) \n                        for i in range(3) for j in range(3)]\n                for i, cell1 in enumerate(cells):\n                    for cell2 in cells[i+1:]:\n                        constraints.append((cell1, cell2))\n\n        return constraints\n\n    def is_consistent(self, var, value, assignment):\n        for neighbor in self.get_neighbors(var):\n            if neighbor in assignment and assignment[neighbor] == value:\n                return False\n        return True\n\n    def get_neighbors(self, var):\n        neighbors = set()\n        for constraint in self.constraints:\n            if var in constraint:\n                neighbors.add(constraint[1] if constraint[0] == var else constraint[0])\n        return neighbors\n</code></pre>"},{"location":"portifolio-3/#estrategias-de-resolucao-de-csps","title":"Estrat\u00e9gias de Resolu\u00e7\u00e3o de CSPs","text":""},{"location":"portifolio-3/#1-backtracking-search","title":"1. Backtracking Search","text":"<p>T\u00e9cnica fundamental para resolver CSPs. Consiste em tentar atribuir valores \u00e0s vari\u00e1veis uma por uma, voltando atr\u00e1s quando encontra um conflito.</p> Python<pre><code>def backtracking_search(csp):\n    def backtrack(assignment):\n        if len(assignment) == len(csp.variables):\n            return assignment\n\n        var = select_unassigned_variable(csp, assignment)\n        for value in order_domain_values(csp, var, assignment):\n            if csp.is_consistent(var, value, assignment):\n                assignment[var] = value\n                result = backtrack(assignment)\n                if result is not None:\n                    return result\n                del assignment[var]\n        return None\n\n    return backtrack({})\n</code></pre>"},{"location":"portifolio-3/#2-forward-checking","title":"2. Forward Checking","text":"<p>T\u00e9cnica de propaga\u00e7\u00e3o de restri\u00e7\u00f5es que mant\u00e9m a consist\u00eancia dos dom\u00ednios das vari\u00e1veis n\u00e3o atribu\u00eddas.</p> Python<pre><code>def forward_checking(csp, var, value, assignment, domains):\n    for neighbor in csp.get_neighbors(var):\n        if neighbor not in assignment:\n            if value in domains[neighbor]:\n                domains[neighbor].remove(value)\n                if not domains[neighbor]:\n                    return False\n    return True\n</code></pre>"},{"location":"portifolio-3/#estrategias-de-selecao-de-variaveis","title":"Estrat\u00e9gias de Sele\u00e7\u00e3o de Vari\u00e1veis","text":""},{"location":"portifolio-3/#1-minimum-remaining-values-mrv","title":"1. Minimum Remaining Values (MRV)","text":"<p>Seleciona a vari\u00e1vel com o menor n\u00famero de valores poss\u00edveis no dom\u00ednio.</p> Python<pre><code>def select_unassigned_variable_mrv(csp, assignment):\n    unassigned = [var for var in csp.variables if var not in assignment]\n    return min(unassigned, key=lambda var: len(csp.domains[var]))\n</code></pre>"},{"location":"portifolio-3/#2-degree-heuristic","title":"2. Degree Heuristic","text":"<p>Seleciona a vari\u00e1vel que est\u00e1 envolvida no maior n\u00famero de restri\u00e7\u00f5es com outras vari\u00e1veis n\u00e3o atribu\u00eddas.</p> Python<pre><code>def select_unassigned_variable_degree(csp, assignment):\n    unassigned = [var for var in csp.variables if var not in assignment]\n    return max(unassigned, key=lambda var: len(csp.get_neighbors(var)))\n</code></pre>"},{"location":"portifolio-3/#estrategias-de-ordenacao-de-valores","title":"Estrat\u00e9gias de Ordena\u00e7\u00e3o de Valores","text":""},{"location":"portifolio-3/#1-least-constraining-value-lcv","title":"1. Least Constraining Value (LCV)","text":"<p>Ordena os valores de forma a minimizar o impacto nas outras vari\u00e1veis.</p> Python<pre><code>def order_domain_values_lcv(csp, var, assignment):\n    def count_conflicts(value):\n        conflicts = 0\n        for neighbor in csp.get_neighbors(var):\n            if neighbor not in assignment and value in csp.domains[neighbor]:\n                conflicts += 1\n        return conflicts\n\n    return sorted(csp.domains[var], key=count_conflicts)\n</code></pre>"},{"location":"portifolio-3/#contribuicoes-e-melhorias","title":"Contribui\u00e7\u00f5es e Melhorias","text":""},{"location":"portifolio-3/#1-algoritmo-de-consistencia-de-arco-ac-3","title":"1. Algoritmo de Consist\u00eancia de Arco (AC-3)","text":"<p>Implementa\u00e7\u00e3o do algoritmo AC-3 para manter a consist\u00eancia de arco:</p> Python<pre><code>def ac3(csp):\n    queue = csp.constraints.copy()\n    while queue:\n        (xi, xj) = queue.pop()\n        if revise(csp, xi, xj):\n            if not csp.domains[xi]:\n                return False\n            for xk in csp.get_neighbors(xi):\n                if xk != xj:\n                    queue.append((xk, xi))\n    return True\n\ndef revise(csp, xi, xj):\n    revised = False\n    for x in csp.domains[xi].copy():\n        if not any(csp.is_consistent(xi, x, {xj: y}) for y in csp.domains[xj]):\n            csp.domains[xi].remove(x)\n            revised = True\n    return revised\n</code></pre>"},{"location":"portifolio-3/#2-algoritmo-de-busca-local","title":"2. Algoritmo de Busca Local","text":"<p>Implementa\u00e7\u00e3o de um algoritmo de busca local para CSPs:</p> Python<pre><code>def min_conflicts(csp, max_steps=1000):\n    assignment = {var: random.choice(list(csp.domains[var])) \n                 for var in csp.variables}\n\n    for _ in range(max_steps):\n        if is_solution(csp, assignment):\n            return assignment\n\n        var = select_conflicted_variable(csp, assignment)\n        value = min_conflicts_value(csp, var, assignment)\n        assignment[var] = value\n\n    return None\n\ndef select_conflicted_variable(csp, assignment):\n    conflicted = []\n    for var in csp.variables:\n        if not csp.is_consistent(var, assignment[var], assignment):\n            conflicted.append(var)\n    return random.choice(conflicted)\n\ndef min_conflicts_value(csp, var, assignment):\n    return min(csp.domains[var], \n              key=lambda value: count_conflicts(csp, var, value, assignment))\n</code></pre>"},{"location":"portifolio-3/#analise-de-desempenho","title":"An\u00e1lise de Desempenho","text":"<p>Nas diferentes estrat\u00e9gias utilizadas, realizamos testes com v\u00e1rios tabuleiros de Sudoku:</p> <ol> <li>Backtracking com MRV + LCV: </li> <li>Mais eficiente para problemas pequenos</li> <li>Garante solu\u00e7\u00e3o \u00f3tima</li> <li> <p>Pode ser lento para problemas grandes</p> </li> <li> <p>Forward Checking:</p> </li> <li>Reduz significativamente o n\u00famero de backtrackings</li> <li>Melhor para problemas com muitas restri\u00e7\u00f5es</li> <li> <p>Custo adicional de manuten\u00e7\u00e3o dos dom\u00ednios</p> </li> <li> <p>AC-3:</p> </li> <li>Muito eficiente para problemas com restri\u00e7\u00f5es bin\u00e1rias</li> <li>Pode resolver alguns problemas sem backtracking</li> <li> <p>Custo computacional maior</p> </li> <li> <p>Min-Conflicts:</p> </li> <li>Excelente para problemas grandes</li> <li>N\u00e3o garante solu\u00e7\u00e3o \u00f3tima</li> <li>Muito r\u00e1pido em m\u00e9dia</li> </ol>"},{"location":"portifolio-3/#demais-exemplos-praticos","title":"Demais Exemplos Pr\u00e1ticos","text":""},{"location":"portifolio-3/#2-problema-das-n-rainhas-n-queens","title":"2. Problema das N-Rainhas (N-Queens)","text":"<p>O objetivo deste problema \u00e9 posicionar N rainhas em um tabuleiro NxN de forma que nenhuma rainha possa atacar outra.</p> Python<pre><code>class NQueensCSP:\n    def __init__(self, n):\n        self.n = n\n        self.variables = list(range(n))  # Cada vari\u00e1vel representa uma coluna\n        self.domains = {var: list(range(n)) for var in self.variables}\n        self.constraints = self._get_constraints()\n\n    def _get_constraints(self):\n        constraints = []\n        for i in range(self.n):\n            for j in range(i + 1, self.n):\n                constraints.append((i, j))\n        return constraints\n\n    def is_consistent(self, var, value, assignment):\n        for col, row in assignment.items():\n            if col == var:\n                continue\n            # Verifica ataques na mesma linha\n            if row == value:\n                return False\n            # Verifica ataques nas diagonais\n            if abs(col - var) == abs(row - value):\n                return False\n        return True\n</code></pre>"},{"location":"portifolio-3/#3-problema-de-coloracao-de-mapas-map-coloring","title":"3. Problema de Colora\u00e7\u00e3o de Mapas (Map Coloring)","text":"<p>Um problema onde o objetivo \u00e9 colorir um mapa com um n\u00famero m\u00ednimo de cores, para garantir que regi\u00f5es adjacentes tenham cores diferentes.</p> Python<pre><code>class MapColoringCSP:\n    def __init__(self, regions, adjacencies, colors):\n        self.variables = regions\n        self.domains = {var: set(colors) for var in self.variables}\n        self.constraints = self._get_constraints(adjacencies)\n\n    def _get_constraints(self, adjacencies):\n        constraints = []\n        for region1, neighbors in adjacencies.items():\n            for region2 in neighbors:\n                if (region2, region1) not in constraints:\n                    constraints.append((region1, region2))\n        return constraints\n\n    def is_consistent(self, var, value, assignment):\n        for neighbor in self.get_neighbors(var):\n            if neighbor in assignment and assignment[neighbor] == value:\n                return False\n        return True\n</code></pre>"},{"location":"portifolio-3/#4-problema-de-horarios-scheduling","title":"4. Problema de Hor\u00e1rios (Scheduling)","text":"<p>Um problema comum em escolas e universidades para criar hor\u00e1rios de aulas, evitando conflitos de professores, salas e turmas.</p> Python<pre><code>class SchedulingCSP:\n    def __init__(self, classes, teachers, rooms, time_slots):\n        self.variables = classes\n        self.domains = {\n            var: [(room, time) for room in rooms for time in time_slots]\n            for var in self.variables\n        }\n        self.teacher_assignments = {class_: teacher for class_, teacher in teachers}\n        self.constraints = self._get_constraints()\n\n    def _get_constraints(self):\n        constraints = []\n        # Restri\u00e7\u00f5es de professor\n        for class1 in self.variables:\n            for class2 in self.variables:\n                if class1 &lt; class2:\n                    if self.teacher_assignments[class1] == self.teacher_assignments[class2]:\n                        constraints.append((class1, class2))\n        return constraints\n\n    def is_consistent(self, var, value, assignment):\n        room, time = value\n        # Verifica conflito de sala\n        for class_, (r, t) in assignment.items():\n            if r == room and t == time:\n                return False\n        # Verifica conflito de professor\n        teacher = self.teacher_assignments[var]\n        for class_, (r, t) in assignment.items():\n            if t == time and self.teacher_assignments[class_] == teacher:\n                return False\n        return True\n</code></pre>"},{"location":"portifolio-3/#5-problema-de-roteamento-de-veiculos-vehicle-routing","title":"5. Problema de Roteamento de Ve\u00edculos (Vehicle Routing)","text":"<p>Um problema de otimiza\u00e7\u00e3o onde o objetivo \u00e9 encontrar rotas \u00f3timas para uma frota de ve\u00edculos atendendo a um conjunto de clientes.</p> Python<pre><code>class VehicleRoutingCSP:\n    def __init__(self, customers, vehicles, capacity_constraints):\n        self.variables = customers\n        self.domains = {\n            var: [(v, pos) for v in vehicles for pos in range(len(customers))]\n            for var in self.variables\n        }\n        self.capacity_constraints = capacity_constraints\n        self.constraints = self._get_constraints()\n\n    def _get_constraints(self):\n        constraints = []\n        # Restri\u00e7\u00f5es de capacidade\n        for v in self.vehicles:\n            customer_assignments = [c for c in self.variables \n                                 if self.domains[c][0] == v]\n            if sum(self.capacity_constraints[c] for c in customer_assignments) &gt; v.capacity:\n                constraints.append(customer_assignments)\n        return constraints\n\n    def is_consistent(self, var, value, assignment):\n        vehicle, position = value\n        # Verifica capacidade\n        current_load = sum(self.capacity_constraints[c] \n                         for c, (v, _) in assignment.items() \n                         if v == vehicle)\n        if current_load + self.capacity_constraints[var] &gt; vehicle.capacity:\n            return False\n        # Verifica posi\u00e7\u00e3o\n        for c, (v, pos) in assignment.items():\n            if v == vehicle and pos == position:\n                return False\n        return True\n</code></pre>"},{"location":"portifolio-3/#6-problema-de-montagem-de-produtos-assembly-line-balancing","title":"6. Problema de Montagem de Produtos (Assembly Line Balancing)","text":"<p>Um problema de otimiza\u00e7\u00e3o onde o objetivo \u00e9 distribuir tarefas de montagem entre esta\u00e7\u00f5es de trabalho, para minimizar o tempo total de ciclo.</p> Python<pre><code>class AssemblyLineCSP:\n    def __init__(self, tasks, stations, task_times, precedences):\n        self.variables = tasks\n        self.domains = {var: list(range(stations)) for var in self.variables}\n        self.task_times = task_times\n        self.precedences = precedences\n        self.constraints = self._get_constraints()\n\n    def _get_constraints(self):\n        constraints = []\n        # Restri\u00e7\u00f5es de preced\u00eancia\n        for task1, task2 in self.precedences:\n            constraints.append((task1, task2))\n        return constraints\n\n    def is_consistent(self, var, value, assignment):\n        # Verifica preced\u00eancia\n        for task1, task2 in self.precedences:\n            if task1 == var and task2 in assignment:\n                if assignment[task2] &lt;= value:\n                    return False\n            elif task2 == var and task1 in assignment:\n                if assignment[task1] &gt;= value:\n                    return False\n        # Verifica tempo de ciclo\n        station_time = sum(self.task_times[t] \n                         for t, s in assignment.items() \n                         if s == value)\n        if station_time + self.task_times[var] &gt; self.cycle_time:\n            return False\n        return True\n</code></pre>"},{"location":"portifolio-3/#conclusao","title":"Conclus\u00e3o","text":"<p>Cada um desses projetos demonstra diferentes aspectos dos CSPs:</p> <ol> <li>Solucionador de Sudoku: Demonstra restri\u00e7\u00f5es complexas em ambiente multivariavel, como exclusividade de valores em linhas, colunas e blocos 3x3</li> <li>N-Rainhas: Demonstra restri\u00e7\u00f5es bin\u00e1rias simples e sim\u00e9tricas, em que nenhuma rainha pode atacar outra na mesma linha, coluna ou diagonal.</li> <li>Colora\u00e7\u00e3o de Mapas: Mostra como modelar problemas com restri\u00e7\u00f5es de adjac\u00eancia, onde regi\u00f5es vizinhas n\u00e3o podem ter a mesma cor.</li> <li>Scheduling: Representa\u00e7\u00e3o de problemas com restri\u00e7\u00f5es m\u00faltiplas e heterog\u00eaneas, como conflitos de hor\u00e1rio, recursos limitados (salas, professores) e prefer\u00eancias.</li> <li>Roteamento de Ve\u00edculos: Envolve restri\u00e7\u00f5es de capacidade, tempo e sequ\u00eancia, como limite de carga dos ve\u00edculos e janelas de entrega.</li> <li>Montagem de Produtos: Demonstra restri\u00e7\u00f5es de preced\u00eancia, sincroniza\u00e7\u00e3o e tempo, comuns em ambientes industriais e de produ\u00e7\u00e3o.</li> </ol> <p>Dessa forma, os Problemas de Satisfa\u00e7\u00e3o de Restri\u00e7\u00f5es (CSPs) demonstram ser uma ferramenta poderosa para modelar e resolver uma ampla variedade de problemas que envolvem restri\u00e7\u00f5es complexas. Durante a an\u00e1lise e desenvolvimento de solu\u00e7\u00f5es baseadas em CSPs, observou-se a import\u00e2ncia da escolha adequada das estrat\u00e9gias de sele\u00e7\u00e3o de vari\u00e1veis e valores, visto que essas decis\u00f5es influenciam diretamente a efici\u00eancia e a viabilidade da resolu\u00e7\u00e3o. Al\u00e9m disso, as t\u00e9cnicas de propaga\u00e7\u00e3o de restri\u00e7\u00f5es mostraram ter um impacto significativo na redu\u00e7\u00e3o do espa\u00e7o de busca, permitindo identificar inconsist\u00eancias precocemente e, assim, acelerar o processo de resolu\u00e7\u00e3o. Tamb\u00e9m foi poss\u00edvel perceber que diferentes algoritmos apresentam desempenhos distintos dependendo do contexto e da estrutura do problema, o que refor\u00e7a a necessidade de uma an\u00e1lise criteriosa para a sele\u00e7\u00e3o do m\u00e9todo mais apropriado.</p> <p>Entre as contribui\u00e7\u00f5es desenvolvidas ao longo do projeto, destacam-se a implementa\u00e7\u00e3o de m\u00faltiplas estrat\u00e9gias de resolu\u00e7\u00e3o, a realiza\u00e7\u00e3o de uma an\u00e1lise comparativa de desempenho entre essas estrat\u00e9gias e a adapta\u00e7\u00e3o de abordagens espec\u00edficas para problemas cl\u00e1ssicos, como o Sudoku, demonstrando a flexibilidade e aplicabilidade dos CSPs em cen\u00e1rios diversos.</p>"},{"location":"portifolio-3/#referencias","title":"Refer\u00eancias","text":"<ol> <li>Russell, S., &amp; Norvig, P. (2020). Artificial Intelligence: A Modern Approach (4\u00aa ed.). Pearson.</li> <li>Dechter, R. (2003). Constraint Processing. Morgan Kaufmann.</li> <li>Kumar, V. (1992). Algorithms for Constraint Satisfaction Problems: A Survey. AI Magazine, 13(1), 32\u201344.</li> <li>Mackworth, A. K. (1977). Consistency in networks of relations. Artificial Intelligence, 8(1), 99\u2013118.</li> <li>Haralick, R. M., &amp; Elliott, G. L. (1980). Increasing tree search efficiency for constraint satisfaction problems. Artificial Intelligence, 14(3), 263\u2013313.</li> <li>Bessiere, C. (2006). Constraint propagation. In Handbook of Constraint Programming, Elsevier, 29\u201383.</li> <li>Apt, K. R. (2003). Principles of Constraint Programming. Cambridge University Press.</li> <li>Rossi, F., van Beek, P., &amp; Walsh, T. (Eds.). (2006). Handbook of Constraint Programming. Elsevier.</li> </ol>"},{"location":"portifolio-4/","title":"Portif\u00f3lio 4","text":""},{"location":"portifolio-4/#agentes-logicos","title":"Agentes L\u00f3gicos","text":"<p>Os agentes l\u00f3gicos ou tamb\u00e9m denominados agentes baseados em conhecimento, representam uma categoria fundamental de agentes artificiais empregando a l\u00f3gica formal como alicerce para a representar conhecimento e racioc\u00ednio. Em sua arquitetura, h\u00e1 concebi\u00e7\u00e3o que possibilita a tomada de decis\u00f5es fundamentadas numa compreens\u00e3o estruturada e inferencial do ambiente, o que diferencia significativamente dos agentes puramente reativos, que operam com base em respostas diretas a est\u00edmulos imediatos.</p>"},{"location":"portifolio-4/#representacao-do-conhecimento-a-fundacao-dos-agentes-logicos","title":"Representa\u00e7\u00e3o do Conhecimento: A Funda\u00e7\u00e3o dos Agentes L\u00f3gicos","text":"<p>Um agente l\u00f3gico, tem como capacidade central a Representa\u00e7\u00e3o do Conhecimento. Por sua vez, este \u00e9 componente que busca permitir que o agente codifique informa\u00e7\u00f5es sobre o mundo de forma expl\u00edcita e simb\u00f3lica, utilizando linguagens formais baseadas em l\u00f3gica, predominantemente a l\u00f3gica proposicional e a l\u00f3gica de primeira ordem (LPO).</p> <ul> <li> <p>L\u00f3gica Proposicional: Utiliza\u00e7\u00e3o de proposi\u00e7\u00f5es (afirma\u00e7\u00f5es que podem ser verdadeiras ou falsas, dependendo do contexto) e conectivos l\u00f3gicos como \"e\" (and), \"ou\" (or), \"n\u00e3o\" (not), \"implica\" (if...then) e \"se e somente se\" (iff) na constru\u00e7\u00e3o de senten\u00e7as complexas. \u00c9 \u00fatil para representar fatos at\u00f4micos e suas inter-rela\u00e7\u00f5es booleanas.   Exemplo: \"\u00c9 dia\" e \"Est\u00e1 sol\" implica \"Vou \u00e0 praia\".</p> </li> <li> <p>L\u00f3gica de Primeira Ordem (LPO): Expande a l\u00f3gica proposicional introduzindo predicados, vari\u00e1veis, quantificadores como \"para todo\" e \"existe\", al\u00e9m de fun\u00e7\u00f5es. Isso confere \u00e0 LPO um poder de express\u00e3o muito maior que permite representar rela\u00e7\u00f5es entre objetos, propriedades de objetos e generaliza\u00e7\u00f5es.   Exemplo: Para toda pessoa x, se x \u00e9 uma pessoa, ent\u00e3o x \u00e9 mortal.   \u00c9 uma capacidade crucial para modelar ambientes complexos, onde h\u00e1 entidades, atributos e rela\u00e7\u00f5es que precisam ser representados com diferentes n\u00edveis de detalhamento.</p> </li> </ul> <p>A partir disso, o conhecimento \u00e9 armazenado numa Base de Conhecimento (BC), sendo um conjunto de senten\u00e7as (axiomas e fatos) expressas na linguagem l\u00f3gica escolhida. Cada senten\u00e7a na Base de Conhecimento contribui para a compreens\u00e3o do agente sobre o estado do ambiente e as regras que o governam.</p>"},{"location":"portifolio-4/#mecanismo-de-inferencia-o-raciocinio-dedutivo","title":"Mecanismo de Infer\u00eancia: O Racioc\u00ednio Dedutivo","text":"<p>O Mecanismo de Infer\u00eancia \u00e9 o motor do racioc\u00ednio em um agente baseado em conhecimento. Ele busca operar sobre a Base de Conhecimento, aplicando regras de infer\u00eancia que deduzam novas senten\u00e7as (conclus\u00f5es) a partir de senten\u00e7as existentes. Este processo \u00e9 an\u00e1logo ao racioc\u00ednio humano, onde novas verdades s\u00e3o derivadas de premissas conhecidas.</p> <ul> <li>Regras de Infer\u00eancia: S\u00e3o procedimentos formais que garantem que, se as premissas forem verdadeiras, a conclus\u00e3o derivada tamb\u00e9m ser\u00e1. Exemplos comuns incluem:<ul> <li>Modus Ponens: Se tivermos as senten\u00e7as \\(A\\) e \\(A \\Rightarrow B\\), podemos inferir \\(B\\).</li> <li>Resolu\u00e7\u00e3o: Um m\u00e9todo de infer\u00eancia completo e semi-decid\u00edvel para a LPO, amplamente utilizado em provadores de teoremas automatizados.</li> </ul> </li> <li>Completude e Decidibilidade: A escolha de um sistema l\u00f3gico e das regras de infer\u00eancia impactam a completude (se todas as verdades podem ser provadas) e a decidibilidade (se existe um algoritmo que sempre termina e determina a verdade de qualquer senten\u00e7a). A l\u00f3gica proposicional \u00e9 decid\u00edvel, enquanto a LPO \u00e9 semi-decid\u00edvel (se uma senten\u00e7a \u00e9 verdadeira, o algoritmo eventualmente a provar\u00e1; se for falsa, pode n\u00e3o terminar).</li> <li>Busca: O processo de infer\u00eancia, muitas vezes envolve uma busca heur\u00edstica ou algor\u00edtmica no espa\u00e7o de estados para encontrar uma prova ou uma solu\u00e7\u00e3o para uma consulta. Algoritmos como busca em largura (BFS), busca em profundidade (DFS) e A* podem ser adaptados para atender a este prop\u00f3sito.</li> </ul>"},{"location":"portifolio-4/#robustez-em-ambientes-parcialmente-observaveis-e-dinamicos","title":"Robustez em Ambientes Parcialmente Observ\u00e1veis e Din\u00e2micos","text":"<p>Uma das grandes vantagens dos agentes l\u00f3gicos \u00e9 a sua aptid\u00e3o para operar em ambientes parcialmente observ\u00e1veis. Nesses cen\u00e1rios, nem todas as informa\u00e7\u00f5es relevantes est\u00e3o diretamente acess\u00edveis atrav\u00e9s dos sensores do agente. Sendo assim, o agente l\u00f3gico compensa essa limita\u00e7\u00e3o ao utilizar seu conhecimento pr\u00e9vio e suas capacidades de infer\u00eancia para deduzir o estado oculto do mundo ou prever eventos futuros. Por exemplo, se um sensor falha, o agente pode inferir a probabilidade de um evento com base em outras observa\u00e7\u00f5es e no conhecimento das leis do dom\u00ednio.</p> <p>A flexibilidade e adaptabilidade s\u00e3o caracter\u00edsticas intr\u00ednsecas devido \u00e0 natureza expl\u00edcita da Base de Conhecimento. Pois altera\u00e7\u00f5es no ambiente ou nos objetivos do agente podem ser acomodadas atrav\u00e9s da modifica\u00e7\u00e3o ou adi\u00e7\u00e3o de senten\u00e7as l\u00f3gicas \u00e0 Base de conhecimento, sem a necessidade de reengenharia completa do agente. Essa modularidade tende a facilitar a manuten\u00e7\u00e3o e a evolu\u00e7\u00e3o do sistema.</p>"},{"location":"portifolio-4/#raciocinio-proativo-e-planejamento-orientado-a-metas","title":"Racioc\u00ednio Proativo e Planejamento Orientado a Metas","text":"<p>OS agentes puramente reativos, respondem a est\u00edmulos de forma condicionada. Por\u00e9m, os agentes l\u00f3gicos exibem racioc\u00ednio proativo e orientado a metas. Essa diferen\u00e7a, garante a capacidade de formular planos complexos, que s\u00e3o sequ\u00eancias de a\u00e7\u00f5es, para alcan\u00e7ar objetivos definidos. Este processo de planejamento envolve:</p> <ol> <li>Definir o Estado Inicial: Conhecimento atual do agente sobre o mundo.</li> <li>Definir o Estado Objetivo: Configura\u00e7\u00e3o desejada do mundo que o agente busca alcan\u00e7ar.</li> <li>A\u00e7\u00f5es: Descri\u00e7\u00e3o das a\u00e7\u00f5es que o agente pode executar e seus efeitos no mundo (condi\u00e7\u00f5es de pr\u00e9-requisito e p\u00f3s-condi\u00e7\u00f5es).</li> <li>Buscar o Espa\u00e7o de Estados: Mecanismo de infer\u00eancia, busca uma sequ\u00eancia de a\u00e7\u00f5es que transforme o estado inicial no estado objetivo, e que considere as regras e restri\u00e7\u00f5es do ambiente. Algoritmos de planejamento como STRIPS, ADL, ou t\u00e9cnicas de Graphplan e SAT-based planning s\u00e3o empregados para este fim.</li> </ol>"},{"location":"portifolio-4/#ciclo-operacional-de-um-agente-logico","title":"Ciclo Operacional de um Agente L\u00f3gico","text":"<p>O funcionamento de um agente l\u00f3gico pode ser encapsulado em um ciclo iterativo:</p> <ol> <li>Percep\u00e7\u00e3o: Recebimento de novas percep\u00e7\u00f5es do ambiente atrav\u00e9s de seus respectivos sensores. Essas percep\u00e7\u00f5es, s\u00e3o convertidas em senten\u00e7as l\u00f3gicas e adicionadas \u00e0 Base de Conhecimento.</li> <li>Atualiza\u00e7\u00e3o da Base de Conhecimento (KB update): Atualiza\u00e7\u00e3o da Base de Conhecimento incorpotando as novas percep\u00e7\u00f5es, garantindo que o conhecimento do agente reflita o estado atual do ambiente. Isso pode envolver adi\u00e7\u00e3o, modifica\u00e7\u00e3o ou remo\u00e7\u00e3o de senten\u00e7as.</li> <li>Racioc\u00ednio/Infer\u00eancia: O mecanismo de infer\u00eancia tem o objetivo de processar a Base de Conhecimento para:<ul> <li>Derivar novas verdades sobre o ambiente.</li> <li>Responder a consultas (e.g., \"Qual \u00e9 a melhor a\u00e7\u00e3o a tomar?\").</li> <li>Detectar inconsist\u00eancias.</li> <li>Gerar um plano de a\u00e7\u00f5es para alcan\u00e7ar um objetivo espec\u00edfico.</li> </ul> </li> <li>A\u00e7\u00e3o: Com base nas conclus\u00f5es do racioc\u00ednio, o agente busca seleciona e executa uma a\u00e7\u00e3o no ambiente atrav\u00e9s de seus atuadores. Esta a\u00e7\u00e3o pode alterar o estado do ambiente e gerar novas percep\u00e7\u00f5es no pr\u00f3ximo ciclo.</li> </ol>"},{"location":"portifolio-4/#aplicacoes-e-relevancia","title":"Aplica\u00e7\u00f5es e Relev\u00e2ncia","text":"<p>Agentes l\u00f3gicos s\u00e3o fundamentais em diversas \u00e1reas da IA:</p> <ul> <li>Sistemas Especialistas: Utilizam bases de conhecimento extensas e regras de infer\u00eancia que emulam o racioc\u00ednio de especialistas humanos em dom\u00ednios espec\u00edficos (e.g., diagn\u00f3stico m\u00e9dico, configura\u00e7\u00e3o de sistemas).</li> <li>Planejamento Automatizado: Desenvolvimento de sequ\u00eancias de a\u00e7\u00f5es para rob\u00f4s, sistemas aut\u00f4nomos ou para gerenciar projetos complexos.</li> <li>Processamento de Linguagem Natural: A l\u00f3gica de primeira ordem pode ser usada na representa\u00e7\u00e3o do significado sem\u00e2ntico de frases, permitindo que m\u00e1quinas compreendam e raciocinem sobre o texto.</li> <li>Representa\u00e7\u00e3o de Conhecimento na Web Sem\u00e2ntica: Fundamentam tecnologias como ontologias e linguagens como OWL permitindo que m\u00e1quinas entendam o significado dos dados na web.</li> </ul>"},{"location":"portifolio-4/#referencias","title":"Refer\u00eancias","text":"<ul> <li>RUSSELL, Stuart J.; NORVIG, Peter. Intelig\u00eancia Artificial. 3. ed. Rio de Janeiro: Elsevier, 2013. (T\u00edtulo original: Artificial Intelligence: A Modern Approach)</li> <li>LUGER, George F. Intelig\u00eancia Artificial: estruturas e estrat\u00e9gias para a resolu\u00e7\u00e3o de problemas complexos. 6. ed. Pearson, 2009.</li> <li>NILSSON, Nils J. Artificial Intelligence: A New Synthesis. Morgan Kaufmann, 1998.</li> <li>BRATKO, Ivan. Prolog Programming for Artificial Intelligence. 4. ed. Pearson Education, 2011.</li> </ul>"}]}