{"config":{"lang":["pt"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Portf\u00f3lio de Intelig\u00eancia Artificial","text":"<p>Este reposit\u00f3rio apresenta os portf\u00f3lios desenvolvidos durante a disciplina de Intelig\u00eancia Artificial, no curso de Engenharia de Software da Universidade de Bras\u00edlia.</p> <p>Baseado nos princ\u00edpios pedag\u00f3gicos de Benigna Maria de Freitas Villas Boas (2008), este portf\u00f3lio \u00e9 uma cole\u00e7\u00e3o comentada e reflexiva de conte\u00fados, conceitos, algoritmos e an\u00e1lises voltados \u00e0 Intelig\u00eancia Artificial, elaboradas ao longo da disciplina. \u00c9 mais do que uma simples reuni\u00e3o de conte\u00fados, o portf\u00f3lio \u00e9 uma ferramenta de aprendizagem ativa, autoavalia\u00e7\u00e3o e demonstra\u00e7\u00e3o de compet\u00eancias.</p> <ul> <li> <p> Portf\u00f3lio 2</p> <p>Explora\u00e7\u00e3o de algoritmos de busca cega e informada, incluindo implementa\u00e7\u00f5es pr\u00e1ticas e an\u00e1lises de desempenho.</p> <p> Acessar</p> </li> <li> <p> Portf\u00f3lio 3</p> <p>Implementa\u00e7\u00e3o e an\u00e1lise de Problemas de Satisfa\u00e7\u00e3o de Restri\u00e7\u00f5es (CSPs) com exemplos pr\u00e1ticos e otimiza\u00e7\u00f5es.</p> <p> Acessar</p> </li> </ul>"},{"location":"#objetivos-do-portfolio","title":"Objetivos do Portf\u00f3lio","text":"<ul> <li>Demonstrar habilidades, compet\u00eancias e valores aprendidos ao longo dos estudos da disciplina;</li> <li>Refletir sobre os conte\u00fados trabalhados em sala de aula e fora dela;</li> <li>Explicar conceitos com autoria pr\u00f3pria, a partir das aulas, pesquisas e estudos individuais;</li> <li>Servir como instrumento de avalia\u00e7\u00e3o formativa pelo professor;</li> <li>Organizar produ\u00e7\u00f5es autorais, como textos, c\u00f3digos e projetos, com an\u00e1lise cr\u00edtica e contextualiza\u00e7\u00e3o.</li> </ul>"},{"location":"#estrutura-dos-topicos","title":"Estrutura dos T\u00f3picos","text":"<p>Os temas do portif\u00f3lio foram estruturados segundo os seguintes elementos:</p> <ol> <li>Introdu\u00e7\u00e3o ao Conte\u00fado </li> <li>Apresenta\u00e7\u00e3o da import\u00e2ncia do tema no contexto socioecon\u00f4mico, pol\u00edtico e tecnol\u00f3gico.</li> <li>Explora\u00e7\u00e3o e An\u00e1lise Cr\u00edtica </li> <li>Organiza\u00e7\u00e3o dos conceitos, com materiais pesquisados, referenciados e comentados.</li> <li>Problemas, Projetos e Aplica\u00e7\u00f5es </li> <li>Proposi\u00e7\u00e3o de exerc\u00edcios, problemas ou projetos autorais com solu\u00e7\u00f5es desenvolvidas e comentadas.</li> <li>Conclus\u00e3o </li> <li>Reflex\u00e3o sobre vantagens, limita\u00e7\u00f5es e principais aprendizados do t\u00f3pico.</li> </ol>"},{"location":"#capitulos-do-portifolio","title":"Cap\u00edtulos do Portif\u00f3lio","text":"<ol> <li>Introdu\u00e7\u00e3o \u00e0 Intelig\u00eancia Artificial</li> <li>Hist\u00f3rico, estado da arte, benef\u00edcios, riscos, agentes inteligentes, ambientes e racionalidade.</li> <li>Resolu\u00e7\u00e3o de Problemas por Busca</li> <li>Busca cega, informada e em ambientes complexos com algoritmos implementados em Python.</li> <li>Problemas de Satisfa\u00e7\u00e3o de Restri\u00e7\u00f5es</li> <li>Modelagem e resolu\u00e7\u00e3o de CSPs (Constraint Satisfaction Problems).</li> <li>Agentes L\u00f3gicos</li> <li>Representa\u00e7\u00e3o do conhecimento e infer\u00eancia por meio da l\u00f3gica proposicional e de predicados.</li> <li>Incerteza e Redes Bayesianas</li> <li>Probabilidade, infer\u00eancia bayesiana, filtros de Kalman e racioc\u00ednio probabil\u00edstico ao longo do tempo.</li> <li>Aprendizado de M\u00e1quina</li> <li>Fundamentos do aprendizado supervisionado, n\u00e3o supervisionado e suas aplica\u00e7\u00f5es pr\u00e1ticas.</li> </ol>"},{"location":"#tecnologias-e-ferramentas-utilizadas","title":"Tecnologias e Ferramentas Utilizadas","text":"<ul> <li>Python \u2013 Implementa\u00e7\u00e3o dos algoritmos</li> <li>MkDocs \u2013 Estrutura e navega\u00e7\u00e3o do portf\u00f3lio</li> <li>MkDocs Material \u2013 Tema visual moderno</li> </ul>"},{"location":"#formato-de-apresentacao","title":"Formato de Apresenta\u00e7\u00e3o","text":"<p>Este portf\u00f3lio utiliza o formato de relat\u00f3rio estruturado com navega\u00e7\u00e3o digital, utilizando o MkDocs. Outras formas, como fichamento, mapa mental ou v\u00eddeo, poder\u00e3o ser adicionadas conforme a necessidade.</p> <p>Todos os materiais s\u00e3o referenciados e comentados, em conformidade com os crit\u00e9rios de avalia\u00e7\u00e3o da disciplina.</p>"},{"location":"#autor-jefferson-sena","title":"Autor: Jefferson Sena","text":"<ul> <li> GitHub</li> <li> LinkedIn</li> </ul> <p>Estudante de Engenharia de Software - Universidade de Bras\u00edlia (UnB) Reposit\u00f3rio acad\u00eamico desenvolvido para a disciplina de Intelig\u00eancia Artificial  </p>"},{"location":"#licenca","title":"Licen\u00e7a","text":"<p>Este material \u00e9 disponibilizado sob a Licen\u00e7a MIT. Uso educacional incentivado.</p> <p>\u201cO portf\u00f3lio \u00e9 um instrumento de avalia\u00e7\u00e3o e reflex\u00e3o que permite que o estudante se reconhe\u00e7a em sua pr\u00f3pria trajet\u00f3ria de aprendizagem.\u201d \u2014 Benigna Maria de Freitas Villas Boas (2008)</p> <p> </p>"},{"location":"portifolio-2/","title":"Portifolio 2","text":""},{"location":"portifolio-2/#algoritmo-de-busca-cega","title":"Algoritmo de busca cega;","text":""},{"location":"portifolio-2/#random-search","title":"Random Search","text":"Python<pre><code>import random\ndef random_search(goal, domain):\nattempts = 0\nwhile True:\nguess = random.choice(domain)\nattempts += 1\nif guess == goal:\nreturn guess, attempts\n</code></pre>"},{"location":"portifolio-2/#o-que-sao-algoritmos-de-busca-cega","title":"O que s\u00e3o Algoritmos de Busca Cega?","text":"<p>Algoritmos de busca cega (ou busca n\u00e3o informada) s\u00e3o algoritmos que n\u00e3o utilizam nenhuma informa\u00e7\u00e3o adicional sobre o problema, como dist\u00e2ncia ou estimativas at\u00e9 o objetivo. Eles exploram o espa\u00e7o de busca de forma sistem\u00e1tica e completa, sem levar em considera\u00e7\u00e3o a posi\u00e7\u00e3o da meta, sendo ent\u00e3o \u201ccegos\u201d quanto ao melhor caminho.</p>"},{"location":"portifolio-2/#origem","title":"Origem","text":"<ul> <li>Surgiram nos anos 1950-60, envolto aos primeiros trabalhos em Intelig\u00eancia Artificial simb\u00f3lica.</li> <li>Aplicados em resolu\u00e7\u00e3o autom\u00e1tica de problemas, como quebra-cabe\u00e7as, jogos simples e sistemas de infer\u00eancia l\u00f3gica.</li> <li>S\u00e3o os primeiros tipos de algoritmos de busca utilizados em IA, tendo ra\u00edzes na teoria de grafos e na teoria dos aut\u00f4matos.</li> </ul>"},{"location":"portifolio-2/#como-funcionam","title":"Como Funcionam?","text":"<p>Eles expandem os n\u00f3s do espa\u00e7o de estados de acordo com uma regra fixa, como:</p> <ul> <li>Em ordem de chegada (fila \u2013 busca em largura).</li> <li>Em ordem de profundidade (pilha \u2013 busca em profundidade).</li> <li>Com menor custo acumulado (busca de custo uniforme).</li> </ul> <p>Esses algoritmos, n\u00e3o sabem se est\u00e3o se aproximando da meta. Apenas tentam todos os caminhos poss\u00edveis dentro do contexto.</p>"},{"location":"portifolio-2/#contextos-de-aplicacao","title":"Contextos de Aplica\u00e7\u00e3o","text":"<p>Embora menos eficientes que os algoritmos informados, os algoritmos de busca cega ainda s\u00e3o \u00fateis quando:</p> <ul> <li>N\u00e3o h\u00e1 informa\u00e7\u00e3o heur\u00edstica confi\u00e1vel dispon\u00edvel.</li> <li>O espa\u00e7o de busca \u00e9 pequeno.</li> <li>\u00c9 necess\u00e1rio garantir que a solu\u00e7\u00e3o seja \u00f3tima ou completa, mesmo sem pistas.</li> </ul> <p>Exemplos de aplica\u00e7\u00f5es:</p> <ul> <li>Solu\u00e7\u00f5es para problemas cl\u00e1ssicos de IA como o problema das torres de Han\u00f3i, quebra-cabe\u00e7as 8-puzzle.</li> <li>Sistemas educacionais, para ensinar l\u00f3gica de busca.</li> <li>Diagn\u00f3stico automatizado onde a heur\u00edstica n\u00e3o \u00e9 clara.</li> <li>Planejamento de a\u00e7\u00f5es simples em jogos e agentes aut\u00f4nomos.</li> </ul>"},{"location":"portifolio-2/#importancia","title":"Import\u00e2ncia","text":"<ul> <li>S\u00e3o a base conceitual para algoritmos mais avan\u00e7ados.</li> <li>Garantem completude (encontram a solu\u00e7\u00e3o, se houver uma).</li> <li>Podem ser usados em qualquer tipo de problema, mesmo sem conhecimento do dom\u00ednio.</li> <li>S\u00e3o \u00fateis para compara\u00e7\u00e3o e benchmarking de novos algoritmos.</li> </ul>"},{"location":"portifolio-2/#1-busca-exaustiva-brute-force-search","title":"1. Busca Exaustiva (Brute-force Search)","text":"<ul> <li>Verifica todas as combina\u00e7\u00f5es poss\u00edveis at\u00e9 encontrar a solu\u00e7\u00e3o.</li> <li>Muito lento, mas simples e confi\u00e1vel.</li> <li>Usado quando o espa\u00e7o de busca \u00e9 pequeno ou para validar solu\u00e7\u00f5es.</li> </ul> Text Only<pre><code>def brute_force_search(problem):\n    for solution in problem.all_possible_solutions():\n        if problem.is_goal(solution):\n            return solution\n    return None\n#Aplicacao: Tentar todas as senhas poss\u00edveis de um cadeado.\n</code></pre>"},{"location":"portifolio-2/#2-backtracking","title":"2. Backtracking","text":"<ul> <li>T\u00e9cnica de busca recursiva que volta atr\u00e1s quando encontra um beco sem sa\u00edda.</li> <li>Muito usada em problemas de combina\u00e7\u00e3o e permuta\u00e7\u00e3o, como Sudoku e quebra-cabe\u00e7as.</li> </ul> Python<pre><code>def solve(problem, state):\n    if problem.is_goal(state):\n        return state\n    for move in problem.legal_moves(state):\n        next_state = problem.apply_move(state, move)\n        result = solve(problem, next_state)\n        if result:\n            return result\n    return None\n#Aplicacao: Resolver o Sudoku ou labirintos.\n</code></pre>"},{"location":"portifolio-2/#3-iterative-deepening-search-ids","title":"3. Iterative Deepening Search (IDS)","text":"<ul> <li>Combina\u00e7\u00e3o de profundidade com garantia de completude.</li> <li>Executa v\u00e1rias buscas em profundidade com profundidade limitada que vai aumentando.</li> <li>Usa pouca mem\u00f3ria encontrando solu\u00e7\u00f5es \u00f3timas.</li> </ul>"},{"location":"portifolio-2/#aplicacao-sudoku-com-backtracking","title":"Aplica\u00e7\u00e3o: Sudoku com Backtracking","text":"<p>Imagine que voc\u00ea est\u00e1 resolvendo um Sudoku. Voc\u00ea n\u00e3o sabe qual n\u00famero colocar, ent\u00e3o tenta todos de 1 a 9 em uma c\u00e9lula vazia. Caso d\u00ea erro, voc\u00ea volta atr\u00e1s e tenta outro n\u00famero \u2014 esse \u00e9 o comportamento t\u00edpico da busca cega com backtracking.</p>"},{"location":"portifolio-2/#algoritmo-de-busca-informada","title":"Algoritmo de busca informada;","text":""},{"location":"portifolio-2/#algoritmo-de-simulated-annealing","title":"Algoritmo de Simulated Annealing","text":"Python<pre><code>import math\nimport random\n\ndef simulated_annealing(objective_function, domain, temp_initial, cooling_rate):\n    current = random.uniform(*domain)\n    temp = temp_initial\n\n    while temp &gt; 1:\n        neighbor = current + random.uniform(-1, 1)\n        neighbor = max(min(neighbor, domain[1]), domain[0])\n        cost_diff = objective_function(neighbor) - objective_function(current)\n\n        if cost_diff &lt; 0 or math.exp(-cost_diff / temp) &gt; random.random():\n            current = neighbor\n\n        temp *= cooling_rate\n\n    return current\n\n# Exemplo: minimizar a fun\u00e7\u00e3o f(x) = x^2\nresult = simulated_annealing(lambda x: x**2, domain=(-10, 10), temp_initial=100, cooling_rate=0.95)\nprint(f\"Solu\u00e7\u00e3o encontrada: {result}, f(x) = {result**2}\")\n#**Aplica\u00e7\u00e3o:** Otimizar de forma cont\u00ednua as fun\u00e7\u00f5es complexas com m\u00ednimos locais.\n</code></pre>"},{"location":"portifolio-2/#o-que-sao-algoritmos-de-busca-informada","title":"O que s\u00e3o Algoritmos de Busca Informada?","text":"<p>Algoritmos de busca informada, s\u00e3o algoritmos que utilizam informa\u00e7\u00f5es adicionais (heur\u00edsticas) sobre o problema para a tomada de decis\u00f5es mais inteligentes durante a busca por solu\u00e7\u00f5es. Tendem a ser mais eficientes do que algoritmos de busca cega (como BFS ou DFS) porque conseguem priorizar caminhos promissores e assim evitar explorar caminhos irrelevantes.</p>"},{"location":"portifolio-2/#origem_1","title":"Origem","text":"<ul> <li>Deriva\u00e7\u00f5es de pesquisas em ci\u00eancia da computa\u00e7\u00e3o e IA cl\u00e1ssica nas d\u00e9cadas de 1960 e 1970.</li> <li>Fortemente influenciados pelo trabalho de nomes como Alan Turing, John McCarthy e Marvin Minsky.</li> <li>Cresceram com os primeiros sistemas de planejamento autom\u00e1tico e resolu\u00e7\u00e3o de problemas em ambientes como jogos e sistemas especialistas.</li> </ul>"},{"location":"portifolio-2/#como-funcionam_1","title":"Como Funcionam?","text":"<p>Esses algoritmos usam uma fun\u00e7\u00e3o heur\u00edstica <code>h(n)</code> que estima o custo restante de um estado <code>n</code> at\u00e9 a solu\u00e7\u00e3o. Essa fun\u00e7\u00e3o:</p> <ul> <li>N\u00e3o precisa ser perfeita, apenas uma boa estimativa.</li> <li>Ajuda a escolher qual n\u00f3 explorar primeiro com base em qual parece mais promissor.</li> </ul>"},{"location":"portifolio-2/#contextos-de-aplicacao_1","title":"Contextos de Aplica\u00e7\u00e3o","text":"<ul> <li>Jogos de estrat\u00e9gia e tabuleiro (ex.: xadrez, damas, sudoku)</li> <li>Planejamento de rotas (ex.: GPS, log\u00edstica)</li> <li>Rob\u00f3tica (ex.: navega\u00e7\u00e3o de rob\u00f4s aut\u00f4nomos)</li> <li>Diagn\u00f3stico autom\u00e1tico e sistemas especialistas</li> <li>Solu\u00e7\u00f5es em tempo real para IA em videogames</li> <li>Assistentes de voz e NLP (em fases de planejamento de di\u00e1logo)</li> </ul>"},{"location":"portifolio-2/#importancia_1","title":"Import\u00e2ncia","text":"<ul> <li>Efici\u00eancia: Exploram menos n\u00f3s que as buscas cegas.</li> <li>Escalabilidade: Lidam melhor com espa\u00e7os de busca grandes.</li> <li>Adaptabilidade: A heur\u00edstica pode ser ajustada para diferentes dom\u00ednios.</li> <li>S\u00e3o a base para algoritmos como A, IDA, Beam Search e etc.</li> </ul>"},{"location":"portifolio-2/#exemplos-de-algoritmos-de-busca-informada","title":"Exemplos de Algoritmos de Busca Informada","text":""},{"location":"portifolio-2/#1-beam-search","title":"1. Beam Search","text":"<ul> <li>Explora apenas os <code>k</code> melhores caminhos em cada n\u00edvel da \u00e1rvore de busca, limitando o n\u00famero de n\u00f3s expandidos.</li> <li>Usado em NLP (ex: tradu\u00e7\u00e3o autom\u00e1tica), pois \u00e9 mais eficiente do que expandir todos os caminhos poss\u00edveis.</li> </ul> Python<pre><code>import heapq\n\ndef beam_search(start, goal, neighbors, heuristic, beam_width):\n    beam = [(heuristic(start, goal), start)]\n    while beam:\n        new_beam = []\n        for _, node in beam:\n            if node == goal:\n                return node\n            for neighbor in neighbors(node):\n                cost = heuristic(neighbor, goal)\n                heapq.heappush(new_beam, (cost, neighbor))\n        beam = heapq.nsmallest(beam_width, new_beam)\n    return None\n</code></pre>"},{"location":"portifolio-2/#2-iterative-deepening-a-ida","title":"2. Iterative Deepening A (IDA)","text":"<ul> <li>Combina a busca em profundidade com heur\u00edsticas.</li> <li>Utiliza limites crescentes baseados na fun\u00e7\u00e3o <code>f(n) = g(n) + h(n)</code>.</li> </ul>"},{"location":"portifolio-2/#3-weighted-a","title":"3. Weighted A*","text":"<ul> <li>Variante do A*, mas multiplica a heur\u00edstica por um fator <code>w</code>:<ul> <li><code>f(n) = g(n) + w * h(n)</code></li> </ul> </li> <li>Com <code>w &gt; 1</code>, torna-se mais r\u00e1pido, mas menos preciso.</li> <li>Usado quando o tempo \u00e9 mais importante que a perfei\u00e7\u00e3o (ex: jogos ou rob\u00f4s em tempo real).</li> </ul>"},{"location":"portifolio-2/#exemplo-de-aplicacao-planejamento-de-rota-com-beam-search","title":"Exemplo de Aplica\u00e7\u00e3o: Planejamento de Rota com Beam Search","text":"<p>Imagine um rob\u00f4 de limpeza que decida o caminho mais eficiente at\u00e9 um ponto para recarregar. O mapa da casa \u00e9 representado como um grafo. O algoritmo usa a dist\u00e2ncia euclidiana como heur\u00edstica decidindo quais caminhos explorar primeiro, evitando paredes e obst\u00e1culos.</p>"},{"location":"portifolio-2/#algoritmo-de-busca-em-ambientes-complexos-gradient-descent-ou-hill-climbing","title":"Algoritmo de busca em ambientes complexos (Gradient Descent ou Hill Climbing)","text":""},{"location":"portifolio-2/#ambiente-complexo-algoritmo-de-gradiente-descendente","title":"Ambiente Complexo \u2014 Algoritmo de Gradiente Descendente","text":"Python<pre><code>def gradient_descent(derivative_func, start, learning_rate, n_iterations):\n    x = start\n    for _ in range(n_iterations):\n        grad = derivative_func(x)\n        x = x - learning_rate * grad\n    return x\n\n# Exemplo: minimizar f(x) = x^2 \u2192 f'(x) = 2x\nminimum = gradient_descent(lambda x: 2*x, start=10.0, learning_rate=0.1, n_iterations=100)\nprint(f\"M\u00ednimo encontrado: x = {minimum}, f(x) = {minimum**2}\")\n</code></pre>"},{"location":"portifolio-2/#o-que-sao-algoritmos-de-busca-em-ambientes-complexos","title":"O que s\u00e3o Algoritmos de Busca em Ambientes Complexos?","text":"<p>S\u00e3o algoritmos usados quando o espa\u00e7o de busca \u00e9 muito grande, cont\u00ednuo ou din\u00e2mico, o que torna invi\u00e1vel testar todas as solu\u00e7\u00f5es poss\u00edveis. Eles buscam melhorar uma solu\u00e7\u00e3o progressivamente, explorando os arredores de uma solu\u00e7\u00e3o atual com base em algum crit\u00e9rio de melhoria.</p>"},{"location":"portifolio-2/#principais-tipos","title":"Principais Tipos","text":""},{"location":"portifolio-2/#1-gradient-descent-descida-do-gradiente","title":"1. Gradient Descent (Descida do Gradiente)","text":"<ul> <li>Tipo: Algoritmo de otimiza\u00e7\u00e3o cont\u00ednua.</li> <li>Utiliza\u00e7\u00e3o: A fun\u00e7\u00e3o objetivo \u00e9 diferenci\u00e1vel (ou seja, podemos calcular sua derivada).</li> <li>Ideia: Dado um ponto inicial, move-se na dire\u00e7\u00e3o do gradiente negativo da fun\u00e7\u00e3o, que \u00e9 a dire\u00e7\u00e3o de maior \"decl\u00ednio\" da fun\u00e7\u00e3o.</li> </ul>"},{"location":"portifolio-2/#como-funciona","title":"Como funciona:","text":"<ol> <li>Escolhe-se uma solu\u00e7\u00e3o inicial (ex: peso de um modelo).</li> <li>Calcula-se o gradiente (a inclina\u00e7\u00e3o) da fun\u00e7\u00e3o no ponto atual.</li> <li>Move-se na dire\u00e7\u00e3o oposta ao gradiente.</li> <li>Repete-se o processo at\u00e9 atingir um m\u00ednimo local ou global.</li> </ol>"},{"location":"portifolio-2/#formula-basica-x-x-fx","title":"F\u00f3rmula b\u00e1sica:   x = x - \u03b1 * \u2207f(x)","text":""},{"location":"portifolio-2/#2-busca-local-hill-climbing-simulated-annealing-etc","title":"2. Busca Local (Hill Climbing, Simulated Annealing, etc.)","text":"<ul> <li>Tipo: Heur\u00edsticas de otimiza\u00e7\u00e3o baseadas em melhorar uma solu\u00e7\u00e3o atual.</li> <li>Diferente do Gradient Descent: N\u00e3o depende de derivadas, funciona com fun\u00e7\u00f5es n\u00e3o cont\u00ednuas.</li> <li>Exemplo relevante: Simulated Annealing, que permite aceitar piores solu\u00e7\u00f5es com alguma probabilidade para escapar de m\u00ednimos locais.</li> </ul>"},{"location":"portifolio-2/#origem-e-contexto-historico","title":"Origem e Contexto Hist\u00f3rico","text":"<ul> <li>O Gradient Descent surgiu no contexto do c\u00e1lculo multivariado e foi adaptado para problemas de IA a partir da d\u00e9cada de 1950.</li> <li>Tornou-se extremamente popular na aprendizagem de m\u00e1quina com o surgimento das redes neurais.</li> <li>M\u00e9todos de busca local t\u00eam origem em t\u00e9cnicas de otimiza\u00e7\u00e3o cl\u00e1ssica, mas evolu\u00edram para lidar com problemas n\u00e3o determin\u00edsticos e estoc\u00e1sticos em IA.</li> </ul>"},{"location":"portifolio-2/#aplicacoes-na-inteligencia-artificial","title":"Aplica\u00e7\u00f5es na Intelig\u00eancia Artificial","text":""},{"location":"portifolio-2/#gradient-descent","title":"Gradient Descent:","text":"<ul> <li>Aprendizado de m\u00e1quina: Treinamento de redes neurais profundas, regress\u00e3o log\u00edstica, SVM, etc.</li> <li>Redu\u00e7\u00e3o de erro: Minimiza uma fun\u00e7\u00e3o de custo, como erro quadr\u00e1tico m\u00e9dio (MSE).</li> <li>Modelos probabil\u00edsticos: Ajuste de par\u00e2metros em modelos como Naive Bayes ou HMM.</li> </ul>"},{"location":"portifolio-2/#outros-algoritmos-de-busca-local","title":"Outros algoritmos de busca local:","text":"<ul> <li>Otimiza\u00e7\u00e3o de hiperpar\u00e2metros (ex: n\u00famero de neur\u00f4nios, taxa de aprendizado).</li> <li>Planejamento de a\u00e7\u00f5es em IA (com Simulated Annealing ou algoritmos estoc\u00e1sticos).</li> <li>IA em jogos e rob\u00f3tica, onde o ambiente muda e n\u00e3o h\u00e1 tempo para uma busca exaustiva.</li> </ul>"},{"location":"portifolio-2/#exemplos-de-algoritmos","title":"Exemplos de Algoritmos","text":""},{"location":"portifolio-2/#1-gradient-descent","title":"1. Gradient Descent","text":"Python<pre><code># Minimizar a fun\u00e7\u00e3o f(x) = (x - 5)**2\ndef f(x):\n    return (x - 5)**2\n\ndef grad_f(x):\n    return 2 * (x - 5)\n\nx = 0  # ponto inicial\nlr = 0.1  # taxa de aprendizado\n\nfor _ in range(100):\n    x -= lr * grad_f(x)\n\nprint(f\"M\u00ednimo encontrado em x = {x}\")\n#Converge para x = 5, que \u00e9 o m\u00ednimo global da fun\u00e7\u00e3o.\n</code></pre>"},{"location":"portifolio-2/#2-simulated-annealing-busca-local-com-perturbacoes","title":"2. Simulated Annealing (busca local com perturba\u00e7\u00f5es)","text":"Python<pre><code>import math\nimport random\n\ndef objective(x):\n    return (x - 3)**2 + 2\n\nx = random.uniform(-10, 10)\nT = 1.0\nT_min = 0.0001\nalpha = 0.9\n\nwhile T &gt; T_min:\n    new_x = x + random.uniform(-1, 1)\n    delta = objective(new_x) - objective(x)\n    if delta &lt; 0 or random.random() &lt; math.exp(-delta / T):\n        x = new_x\n    T *= alpha\n\nprint(f\"Melhor solu\u00e7\u00e3o encontrada: x = {x}\")\n</code></pre>"},{"location":"portifolio-2/#importancia-dos-algoritmos-em-ambientes-complexos","title":"Import\u00e2ncia dos Algoritmos em Ambientes Complexos","text":"<ul> <li>S\u00e3o fundamentais para resolver problemas onde:<ul> <li>O espa\u00e7o de busca \u00e9 enorme ou cont\u00ednuo.</li> <li>A solu\u00e7\u00e3o exata n\u00e3o \u00e9 conhecida.</li> <li>\u00c9 necess\u00e1rio tempo real ou adapta\u00e7\u00e3o constante (ex: IA em jogos, carros aut\u00f4nomos).</li> </ul> </li> <li>Est\u00e3o na base de muitos avan\u00e7os modernos em deep learning e intelig\u00eancia artificial.</li> </ul> Conceito Gradient Descent Busca Local Precisa de derivada? Sim N\u00e3o Tipo de fun\u00e7\u00e3o Cont\u00ednua Arbitr\u00e1ria Exemplo Treinamento de rede neural Planejamento em IA Vantagem Converg\u00eancia r\u00e1pida Vers\u00e1til para ambientes estoc\u00e1sticos"},{"location":"portifolio-2/#algoritmo-genetico","title":"Algoritmo gen\u00e9tico","text":"Python<pre><code>import random\n\ndef fitness(x):\n    return -1 * (x - 3)**2 + 9  # M\u00e1ximo em x = 3\n\ndef genetic_algorithm(population, generations, mutation_rate=0.1):\n    for _ in range(generations):\n        population.sort(key=fitness, reverse=True)\n        next_gen = population[:2]  # elitismo\n\n        while len(next_gen) &lt; len(population):\n            p1, p2 = random.sample(population[:4], 2)\n            child = (p1 + p2) / 2\n            if random.random() &lt; mutation_rate:\n                child += random.uniform(-1, 1)\n            next_gen.append(child)\n\n        population = next_gen\n\n    best = max(population, key=fitness)\n    return best\n\n# Exemplo: encontrar o m\u00e1ximo da fun\u00e7\u00e3o - (x-3)^2 + 9\ninitial_pop = [random.uniform(0, 6) for _ in range(6)]\nsolution = genetic_algorithm(initial_pop, generations=20)\nprint(f\"Solu\u00e7\u00e3o gen\u00e9tica: x = {solution}, f(x) = {fitness(solution)}\")\n</code></pre>"},{"location":"portifolio-2/#o-que-sao-algoritmos-geneticos","title":"O que s\u00e3o Algoritmos Gen\u00e9ticos?","text":"<p>Algoritmos Gen\u00e9ticos (AGs) s\u00e3o t\u00e9cnicas de otimiza\u00e7\u00e3o e busca inspiradas nos processos de sele\u00e7\u00e3o natural e evolu\u00e7\u00e3o biol\u00f3gica descritos por Charles Darwin. Eles pertencem \u00e0 categoria de algoritmos evolutivos, que usam conceitos como popula\u00e7\u00e3o, muta\u00e7\u00e3o, reprodu\u00e7\u00e3o e sele\u00e7\u00e3o para resolver problemas complexos.</p>"},{"location":"portifolio-2/#origem-dos-algoritmos-geneticos","title":"Origem dos Algoritmos Gen\u00e9ticos","text":"<ul> <li>Foram propostos por John Holland na d\u00e9cada de 1970, na Universidade de Michigan.</li> <li>Holland criou uma estrutura matem\u00e1tica para entender os mecanismos da evolu\u00e7\u00e3o natural e adapt\u00e1-los \u00e0 resolu\u00e7\u00e3o de problemas computacionais.</li> <li>Seu livro de 1975, \"Adaptation in Natural and Artificial Systems\", \u00e9 a base te\u00f3rica dos AGs.</li> </ul>"},{"location":"portifolio-2/#como-funcionam-os-algoritmos-geneticos","title":"Como Funcionam os Algoritmos Gen\u00e9ticos?","text":"<ol> <li>Inicializa\u00e7\u00e3o: Uma popula\u00e7\u00e3o inicial de solu\u00e7\u00f5es (chamadas de indiv\u00edduos ou cromossomos) \u00e9 gerada aleatoriamente.</li> <li>Avalia\u00e7\u00e3o (Fitness): Cada indiv\u00edduo \u00e9 avaliado por uma fun\u00e7\u00e3o de aptid\u00e3o (fitness function) que mede qu\u00e3o boa \u00e9 a solu\u00e7\u00e3o.</li> <li>Sele\u00e7\u00e3o: Indiv\u00edduos mais aptos t\u00eam mais chances de serem escolhidos para gerar descendentes.</li> <li>Crossover (Recombina\u00e7\u00e3o): Partes dos cromossomos dos pais s\u00e3o combinadas para criar novos indiv\u00edduos.</li> <li>Muta\u00e7\u00e3o: Pequenas altera\u00e7\u00f5es aleat\u00f3rias s\u00e3o feitas nos descendentes para manter diversidade gen\u00e9tica.</li> <li>Substitui\u00e7\u00e3o: Uma nova gera\u00e7\u00e3o substitui (total ou parcialmente) a antiga.</li> <li>Itera\u00e7\u00e3o: O processo se repete por v\u00e1rias gera\u00e7\u00f5es at\u00e9 que uma condi\u00e7\u00e3o de parada seja satisfeita (ex: n\u00famero m\u00e1ximo de gera\u00e7\u00f5es, solu\u00e7\u00e3o suficientemente boa, etc).</li> </ol>"},{"location":"portifolio-2/#contextos-de-aplicacao-dos-algoritmos-geneticos","title":"Contextos de Aplica\u00e7\u00e3o dos Algoritmos Gen\u00e9ticos","text":"<p>AGs s\u00e3o usados em problemas de otimiza\u00e7\u00e3o complexos, onde n\u00e3o h\u00e1 uma solu\u00e7\u00e3o exata vi\u00e1vel ou onde o espa\u00e7o de busca \u00e9 muito grande:</p>"},{"location":"portifolio-2/#exemplos-de-aplicacoes","title":"Exemplos de aplica\u00e7\u00f5es:","text":"<ul> <li>Otimiza\u00e7\u00e3o de rotas: problema do caixeiro viajante (TSP), roteamento de entregas.</li> <li>Agendamento: aloca\u00e7\u00e3o de tarefas em f\u00e1bricas ou escalas de funcion\u00e1rios.</li> <li>Design de redes neurais: otimiza\u00e7\u00e3o de hiperpar\u00e2metros de redes profundas.</li> <li>Engenharia: design de circuitos eletr\u00f4nicos, estruturas mec\u00e2nicas.</li> <li>Bioinform\u00e1tica: alinhamento de sequ\u00eancias gen\u00e9ticas, previs\u00e3o de estrutura de prote\u00ednas.</li> <li>Criptografia: quebra de cifras por tentativa evolutiva.</li> <li>Jogos e IA: criar NPCs adaptativos ou estrat\u00e9gias vencedoras.</li> </ul>"},{"location":"portifolio-2/#por-que-algoritmos-geneticos-sao-importantes","title":"Por que Algoritmos Gen\u00e9ticos s\u00e3o Importantes?","text":"<ul> <li>Robustez: Funcionam bem mesmo com fun\u00e7\u00f5es de custo n\u00e3o lineares, descont\u00ednuas ou com m\u00faltiplos \u00f3timos locais.</li> <li>Paralelismo natural: Por usar popula\u00e7\u00f5es, podem explorar v\u00e1rias solu\u00e7\u00f5es ao mesmo tempo.</li> <li>Generalidade: Podem ser aplicados a muitos tipos diferentes de problemas.</li> <li>N\u00e3o precisam de derivadas: Diferente do gradiente descendente, AGs n\u00e3o exigem fun\u00e7\u00f5es diferenci\u00e1veis.</li> </ul>"},{"location":"portifolio-2/#exemplos-de-algoritmos-geneticos-e-variantes","title":"Exemplos de Algoritmos Gen\u00e9ticos e Variantes","text":"<ol> <li>Algoritmo Gen\u00e9tico Cl\u00e1ssico (GA):<ul> <li>Baseado nos operadores b\u00e1sicos: sele\u00e7\u00e3o, crossover e muta\u00e7\u00e3o.</li> </ul> </li> <li>Algoritmo Gen\u00e9tico com Elitismo:<ul> <li>Garante que os melhores indiv\u00edduos de uma gera\u00e7\u00e3o sobrevivem \u00e0 pr\u00f3xima.</li> </ul> </li> <li>Algoritmos Gen\u00e9ticos Multiobjetivo (ex: NSGA-II):<ul> <li>Resolvem problemas com m\u00faltiplos crit\u00e9rios de otimiza\u00e7\u00e3o.</li> </ul> </li> <li>Algoritmos Evolutivos Diferenciais:<ul> <li>Variante que usa diferen\u00e7as entre solu\u00e7\u00f5es para gerar novas.</li> </ul> </li> <li>Algoritmos Gen\u00e9ticos com Codifica\u00e7\u00e3o Real:<ul> <li>Ao inv\u00e9s de bits, usam n\u00fameros reais (mais comum em otimiza\u00e7\u00e3o cont\u00ednua).</li> </ul> </li> </ol>"},{"location":"portifolio-2/#referencias","title":"Refer\u00eancias","text":"<ul> <li>RUSSELL, Stuart J.; NORVIG, Peter. Intelig\u00eancia Artificial. 3. ed. Rio de Janeiro: Elsevier, 2013.   (T\u00edtulo original: Artificial Intelligence: A Modern Approach)</li> <li>LUGER, George F. Intelig\u00eancia Artificial: estruturas e estrat\u00e9gias para a resolu\u00e7\u00e3o de problemas complexos. 6. ed. Pearson, 2009.</li> <li>GOLDBERG, David E. Algoritmos Gen\u00e9ticos em Busca, Otimiza\u00e7\u00e3o e Aprendizado de M\u00e1quina. Pearson Education, 1989.</li> <li>HOLLAND, John H. Adaptation in Natural and Artificial Systems. MIT Press, 1992.</li> <li>MITCHELL, Melanie. An Introduction to Genetic Algorithms. MIT Press, 1996.</li> <li>GOODFELLOW, Ian; BENGIO, Yoshua; COURVILLE, Aaron. Deep Learning. MIT Press, 2016. Dispon\u00edvel em: https://www.deeplearningbook.org/</li> <li>HASTIE, Trevor; TIBSHIRANI, Robert; FRIEDMAN, Jerome. The Elements of Statistical Learning. Springer, 2009.</li> <li>OpenAI Blog \u2013 AI concepts and research: https://openai.com/research</li> <li>Towards Data Science \u2013 Medium Publication: https://towardsdatascience.com/</li> <li>Geeks for Geeks \u2013 AI/ML tutorials: https://www.geeksforgeeks.org/fundamentals-of-artificial-intelligence/</li> <li>Stanford University \u2013 AI Course Materials: https://cs221.stanford.edu/</li> </ul>"},{"location":"portifolio-3/","title":"Portf\u00f3lio 3 - Constraint Satisfaction Problems - CSP","text":""},{"location":"portifolio-3/#introducao-aos-csps","title":"Introdu\u00e7\u00e3o aos CSPs","text":"<p>Problemas de Satisfa\u00e7\u00e3o de Restri\u00e7\u00f5es (CSPs), trata-se de uma classe de problemas onde o objetivo \u00e9 encontrar valores para um conjunto de vari\u00e1veis que satisfa um conjunto de restri\u00e7\u00f5es. Formalmente, um CSP consiste em:</p> <ul> <li>Um conjunto de vari\u00e1veis X = {X\u2081, X\u2082, ..., X\u2099}</li> <li>Um conjunto de dom\u00ednios D = {D\u2081, D\u2082, ..., D\u2099}, onde cada D\u1d62 \u00e9 o conjunto de valores poss\u00edveis para X\u1d62</li> <li>Um conjunto de restri\u00e7\u00f5es C = {C\u2081, C\u2082, ..., C\u2098} que especificam combina\u00e7\u00f5es v\u00e1lidas de valores</li> </ul>"},{"location":"portifolio-3/#11-exemplo-pratico-solucionador-de-sudoku-simples-usando-csp","title":"1.1 Exemplo Pr\u00e1tico: Solucionador de Sudoku Simples usando CSP","text":"<p>Neste exemplo, implemento um solucionador de Sudoku utilizando t\u00e9cnicas de CSP.</p> <ul> <li>Vari\u00e1veis: 81 c\u00e9lulas do tabuleiro (9x9)</li> <li>Dom\u00ednios: N\u00fameros de 1 a 9 para cada c\u00e9lula</li> <li>Restri\u00e7\u00f5es: </li> <li>Cada linha cont\u00e9m n\u00fameros \u00fanicos de 1 a 9</li> <li>Cada coluna cont\u00e9m n\u00fameros \u00fanicos de 1 a 9</li> <li>Cada subgrade 3x3 cont\u00e9m n\u00fameros \u00fanicos de 1 a 9</li> </ul> Python<pre><code>class SudokuCSP:\n    def __init__(self, board):\n        self.board = board\n        self.variables = [(i, j) for i in range(9) for j in range(9)]\n        self.domains = {var: set(range(1, 10)) for var in self.variables}\n        self.constraints = self._get_constraints()\n\n    def _get_constraints(self):\n        constraints = []\n        # Restri\u00e7\u00f5es de linha\n        for i in range(9):\n            for j in range(9):\n                for k in range(j + 1, 9):\n                    constraints.append(((i, j), (i, k)))\n\n        # Restri\u00e7\u00f5es de coluna\n        for j in range(9):\n            for i in range(9):\n                for k in range(i + 1, 9):\n                    constraints.append(((i, j), (k, j)))\n\n        # Restri\u00e7\u00f5es de subgrade 3x3\n        for block_i in range(3):\n            for block_j in range(3):\n                cells = [(3*block_i + i, 3*block_j + j) \n                        for i in range(3) for j in range(3)]\n                for i, cell1 in enumerate(cells):\n                    for cell2 in cells[i+1:]:\n                        constraints.append((cell1, cell2))\n\n        return constraints\n\n    def is_consistent(self, var, value, assignment):\n        for neighbor in self.get_neighbors(var):\n            if neighbor in assignment and assignment[neighbor] == value:\n                return False\n        return True\n\n    def get_neighbors(self, var):\n        neighbors = set()\n        for constraint in self.constraints:\n            if var in constraint:\n                neighbors.add(constraint[1] if constraint[0] == var else constraint[0])\n        return neighbors\n</code></pre>"},{"location":"portifolio-3/#estrategias-de-resolucao-de-csps","title":"Estrat\u00e9gias de Resolu\u00e7\u00e3o de CSPs","text":""},{"location":"portifolio-3/#1-backtracking-search","title":"1. Backtracking Search","text":"<p>T\u00e9cnica fundamental para resolver CSPs. Consiste em tentar atribuir valores \u00e0s vari\u00e1veis uma por uma, voltando atr\u00e1s quando encontra um conflito.</p> Python<pre><code>def backtracking_search(csp):\n    def backtrack(assignment):\n        if len(assignment) == len(csp.variables):\n            return assignment\n\n        var = select_unassigned_variable(csp, assignment)\n        for value in order_domain_values(csp, var, assignment):\n            if csp.is_consistent(var, value, assignment):\n                assignment[var] = value\n                result = backtrack(assignment)\n                if result is not None:\n                    return result\n                del assignment[var]\n        return None\n\n    return backtrack({})\n</code></pre>"},{"location":"portifolio-3/#2-forward-checking","title":"2. Forward Checking","text":"<p>T\u00e9cnica de propaga\u00e7\u00e3o de restri\u00e7\u00f5es que mant\u00e9m a consist\u00eancia dos dom\u00ednios das vari\u00e1veis n\u00e3o atribu\u00eddas.</p> Python<pre><code>def forward_checking(csp, var, value, assignment, domains):\n    for neighbor in csp.get_neighbors(var):\n        if neighbor not in assignment:\n            if value in domains[neighbor]:\n                domains[neighbor].remove(value)\n                if not domains[neighbor]:\n                    return False\n    return True\n</code></pre>"},{"location":"portifolio-3/#estrategias-de-selecao-de-variaveis","title":"Estrat\u00e9gias de Sele\u00e7\u00e3o de Vari\u00e1veis","text":""},{"location":"portifolio-3/#1-minimum-remaining-values-mrv","title":"1. Minimum Remaining Values (MRV)","text":"<p>Seleciona a vari\u00e1vel com o menor n\u00famero de valores poss\u00edveis no dom\u00ednio.</p> Python<pre><code>def select_unassigned_variable_mrv(csp, assignment):\n    unassigned = [var for var in csp.variables if var not in assignment]\n    return min(unassigned, key=lambda var: len(csp.domains[var]))\n</code></pre>"},{"location":"portifolio-3/#2-degree-heuristic","title":"2. Degree Heuristic","text":"<p>Seleciona a vari\u00e1vel que est\u00e1 envolvida no maior n\u00famero de restri\u00e7\u00f5es com outras vari\u00e1veis n\u00e3o atribu\u00eddas.</p> Python<pre><code>def select_unassigned_variable_degree(csp, assignment):\n    unassigned = [var for var in csp.variables if var not in assignment]\n    return max(unassigned, key=lambda var: len(csp.get_neighbors(var)))\n</code></pre>"},{"location":"portifolio-3/#estrategias-de-ordenacao-de-valores","title":"Estrat\u00e9gias de Ordena\u00e7\u00e3o de Valores","text":""},{"location":"portifolio-3/#1-least-constraining-value-lcv","title":"1. Least Constraining Value (LCV)","text":"<p>Ordena os valores de forma a minimizar o impacto nas outras vari\u00e1veis.</p> Python<pre><code>def order_domain_values_lcv(csp, var, assignment):\n    def count_conflicts(value):\n        conflicts = 0\n        for neighbor in csp.get_neighbors(var):\n            if neighbor not in assignment and value in csp.domains[neighbor]:\n                conflicts += 1\n        return conflicts\n\n    return sorted(csp.domains[var], key=count_conflicts)\n</code></pre>"},{"location":"portifolio-3/#contribuicoes-e-melhorias","title":"Contribui\u00e7\u00f5es e Melhorias","text":""},{"location":"portifolio-3/#1-algoritmo-de-consistencia-de-arco-ac-3","title":"1. Algoritmo de Consist\u00eancia de Arco (AC-3)","text":"<p>Implementa\u00e7\u00e3o do algoritmo AC-3 para manter a consist\u00eancia de arco:</p> Python<pre><code>def ac3(csp):\n    queue = csp.constraints.copy()\n    while queue:\n        (xi, xj) = queue.pop()\n        if revise(csp, xi, xj):\n            if not csp.domains[xi]:\n                return False\n            for xk in csp.get_neighbors(xi):\n                if xk != xj:\n                    queue.append((xk, xi))\n    return True\n\ndef revise(csp, xi, xj):\n    revised = False\n    for x in csp.domains[xi].copy():\n        if not any(csp.is_consistent(xi, x, {xj: y}) for y in csp.domains[xj]):\n            csp.domains[xi].remove(x)\n            revised = True\n    return revised\n</code></pre>"},{"location":"portifolio-3/#2-algoritmo-de-busca-local","title":"2. Algoritmo de Busca Local","text":"<p>Implementa\u00e7\u00e3o de um algoritmo de busca local para CSPs:</p> Python<pre><code>def min_conflicts(csp, max_steps=1000):\n    assignment = {var: random.choice(list(csp.domains[var])) \n                 for var in csp.variables}\n\n    for _ in range(max_steps):\n        if is_solution(csp, assignment):\n            return assignment\n\n        var = select_conflicted_variable(csp, assignment)\n        value = min_conflicts_value(csp, var, assignment)\n        assignment[var] = value\n\n    return None\n\ndef select_conflicted_variable(csp, assignment):\n    conflicted = []\n    for var in csp.variables:\n        if not csp.is_consistent(var, assignment[var], assignment):\n            conflicted.append(var)\n    return random.choice(conflicted)\n\ndef min_conflicts_value(csp, var, assignment):\n    return min(csp.domains[var], \n              key=lambda value: count_conflicts(csp, var, value, assignment))\n</code></pre>"},{"location":"portifolio-3/#analise-de-desempenho","title":"An\u00e1lise de Desempenho","text":"<p>Nas diferentes estrat\u00e9gias utilizadas, realizamos testes com v\u00e1rios tabuleiros de Sudoku:</p> <ol> <li>Backtracking com MRV + LCV: </li> <li>Mais eficiente para problemas pequenos</li> <li>Garante solu\u00e7\u00e3o \u00f3tima</li> <li> <p>Pode ser lento para problemas grandes</p> </li> <li> <p>Forward Checking:</p> </li> <li>Reduz significativamente o n\u00famero de backtrackings</li> <li>Melhor para problemas com muitas restri\u00e7\u00f5es</li> <li> <p>Custo adicional de manuten\u00e7\u00e3o dos dom\u00ednios</p> </li> <li> <p>AC-3:</p> </li> <li>Muito eficiente para problemas com restri\u00e7\u00f5es bin\u00e1rias</li> <li>Pode resolver alguns problemas sem backtracking</li> <li> <p>Custo computacional maior</p> </li> <li> <p>Min-Conflicts:</p> </li> <li>Excelente para problemas grandes</li> <li>N\u00e3o garante solu\u00e7\u00e3o \u00f3tima</li> <li>Muito r\u00e1pido em m\u00e9dia</li> </ol>"},{"location":"portifolio-3/#demais-exemplos-praticos","title":"Demais Exemplos Pr\u00e1ticos","text":""},{"location":"portifolio-3/#2-problema-das-n-rainhas-n-queens","title":"2. Problema das N-Rainhas (N-Queens)","text":"<p>O objetivo deste problema \u00e9 posicionar N rainhas em um tabuleiro NxN de forma que nenhuma rainha possa atacar outra.</p> Python<pre><code>class NQueensCSP:\n    def __init__(self, n):\n        self.n = n\n        self.variables = list(range(n))  # Cada vari\u00e1vel representa uma coluna\n        self.domains = {var: list(range(n)) for var in self.variables}\n        self.constraints = self._get_constraints()\n\n    def _get_constraints(self):\n        constraints = []\n        for i in range(self.n):\n            for j in range(i + 1, self.n):\n                constraints.append((i, j))\n        return constraints\n\n    def is_consistent(self, var, value, assignment):\n        for col, row in assignment.items():\n            if col == var:\n                continue\n            # Verifica ataques na mesma linha\n            if row == value:\n                return False\n            # Verifica ataques nas diagonais\n            if abs(col - var) == abs(row - value):\n                return False\n        return True\n</code></pre>"},{"location":"portifolio-3/#3-problema-de-coloracao-de-mapas-map-coloring","title":"3. Problema de Colora\u00e7\u00e3o de Mapas (Map Coloring)","text":"<p>Um problema onde o objetivo \u00e9 colorir um mapa com um n\u00famero m\u00ednimo de cores, para garantir que regi\u00f5es adjacentes tenham cores diferentes.</p> Python<pre><code>class MapColoringCSP:\n    def __init__(self, regions, adjacencies, colors):\n        self.variables = regions\n        self.domains = {var: set(colors) for var in self.variables}\n        self.constraints = self._get_constraints(adjacencies)\n\n    def _get_constraints(self, adjacencies):\n        constraints = []\n        for region1, neighbors in adjacencies.items():\n            for region2 in neighbors:\n                if (region2, region1) not in constraints:\n                    constraints.append((region1, region2))\n        return constraints\n\n    def is_consistent(self, var, value, assignment):\n        for neighbor in self.get_neighbors(var):\n            if neighbor in assignment and assignment[neighbor] == value:\n                return False\n        return True\n</code></pre>"},{"location":"portifolio-3/#4-problema-de-horarios-scheduling","title":"4. Problema de Hor\u00e1rios (Scheduling)","text":"<p>Um problema comum em escolas e universidades para criar hor\u00e1rios de aulas, evitando conflitos de professores, salas e turmas.</p> Python<pre><code>class SchedulingCSP:\n    def __init__(self, classes, teachers, rooms, time_slots):\n        self.variables = classes\n        self.domains = {\n            var: [(room, time) for room in rooms for time in time_slots]\n            for var in self.variables\n        }\n        self.teacher_assignments = {class_: teacher for class_, teacher in teachers}\n        self.constraints = self._get_constraints()\n\n    def _get_constraints(self):\n        constraints = []\n        # Restri\u00e7\u00f5es de professor\n        for class1 in self.variables:\n            for class2 in self.variables:\n                if class1 &lt; class2:\n                    if self.teacher_assignments[class1] == self.teacher_assignments[class2]:\n                        constraints.append((class1, class2))\n        return constraints\n\n    def is_consistent(self, var, value, assignment):\n        room, time = value\n        # Verifica conflito de sala\n        for class_, (r, t) in assignment.items():\n            if r == room and t == time:\n                return False\n        # Verifica conflito de professor\n        teacher = self.teacher_assignments[var]\n        for class_, (r, t) in assignment.items():\n            if t == time and self.teacher_assignments[class_] == teacher:\n                return False\n        return True\n</code></pre>"},{"location":"portifolio-3/#5-problema-de-roteamento-de-veiculos-vehicle-routing","title":"5. Problema de Roteamento de Ve\u00edculos (Vehicle Routing)","text":"<p>Um problema de otimiza\u00e7\u00e3o onde o objetivo \u00e9 encontrar rotas \u00f3timas para uma frota de ve\u00edculos atendendo a um conjunto de clientes.</p> Python<pre><code>class VehicleRoutingCSP:\n    def __init__(self, customers, vehicles, capacity_constraints):\n        self.variables = customers\n        self.domains = {\n            var: [(v, pos) for v in vehicles for pos in range(len(customers))]\n            for var in self.variables\n        }\n        self.capacity_constraints = capacity_constraints\n        self.constraints = self._get_constraints()\n\n    def _get_constraints(self):\n        constraints = []\n        # Restri\u00e7\u00f5es de capacidade\n        for v in self.vehicles:\n            customer_assignments = [c for c in self.variables \n                                 if self.domains[c][0] == v]\n            if sum(self.capacity_constraints[c] for c in customer_assignments) &gt; v.capacity:\n                constraints.append(customer_assignments)\n        return constraints\n\n    def is_consistent(self, var, value, assignment):\n        vehicle, position = value\n        # Verifica capacidade\n        current_load = sum(self.capacity_constraints[c] \n                         for c, (v, _) in assignment.items() \n                         if v == vehicle)\n        if current_load + self.capacity_constraints[var] &gt; vehicle.capacity:\n            return False\n        # Verifica posi\u00e7\u00e3o\n        for c, (v, pos) in assignment.items():\n            if v == vehicle and pos == position:\n                return False\n        return True\n</code></pre>"},{"location":"portifolio-3/#6-problema-de-montagem-de-produtos-assembly-line-balancing","title":"6. Problema de Montagem de Produtos (Assembly Line Balancing)","text":"<p>Um problema de otimiza\u00e7\u00e3o onde o objetivo \u00e9 distribuir tarefas de montagem entre esta\u00e7\u00f5es de trabalho, para minimizar o tempo total de ciclo.</p> Python<pre><code>class AssemblyLineCSP:\n    def __init__(self, tasks, stations, task_times, precedences):\n        self.variables = tasks\n        self.domains = {var: list(range(stations)) for var in self.variables}\n        self.task_times = task_times\n        self.precedences = precedences\n        self.constraints = self._get_constraints()\n\n    def _get_constraints(self):\n        constraints = []\n        # Restri\u00e7\u00f5es de preced\u00eancia\n        for task1, task2 in self.precedences:\n            constraints.append((task1, task2))\n        return constraints\n\n    def is_consistent(self, var, value, assignment):\n        # Verifica preced\u00eancia\n        for task1, task2 in self.precedences:\n            if task1 == var and task2 in assignment:\n                if assignment[task2] &lt;= value:\n                    return False\n            elif task2 == var and task1 in assignment:\n                if assignment[task1] &gt;= value:\n                    return False\n        # Verifica tempo de ciclo\n        station_time = sum(self.task_times[t] \n                         for t, s in assignment.items() \n                         if s == value)\n        if station_time + self.task_times[var] &gt; self.cycle_time:\n            return False\n        return True\n</code></pre>"},{"location":"portifolio-3/#conclusao","title":"Conclus\u00e3o","text":"<p>Cada um desses projetos demonstra diferentes aspectos dos CSPs:</p> <ol> <li>Solucionador de Sudoku: Demonstra restri\u00e7\u00f5es complexas em ambiente multivariavel, como exclusividade de valores em linhas, colunas e blocos 3x3</li> <li>N-Rainhas: Demonstra restri\u00e7\u00f5es bin\u00e1rias simples e sim\u00e9tricas, em que nenhuma rainha pode atacar outra na mesma linha, coluna ou diagonal.</li> <li>Colora\u00e7\u00e3o de Mapas: Mostra como modelar problemas com restri\u00e7\u00f5es de adjac\u00eancia, onde regi\u00f5es vizinhas n\u00e3o podem ter a mesma cor.</li> <li>Scheduling: Representa\u00e7\u00e3o de problemas com restri\u00e7\u00f5es m\u00faltiplas e heterog\u00eaneas, como conflitos de hor\u00e1rio, recursos limitados (salas, professores) e prefer\u00eancias.</li> <li>Roteamento de Ve\u00edculos: Envolve restri\u00e7\u00f5es de capacidade, tempo e sequ\u00eancia, como limite de carga dos ve\u00edculos e janelas de entrega.</li> <li>Montagem de Produtos: Demonstra restri\u00e7\u00f5es de preced\u00eancia, sincroniza\u00e7\u00e3o e tempo, comuns em ambientes industriais e de produ\u00e7\u00e3o.</li> </ol> <p>Dessa forma, os Problemas de Satisfa\u00e7\u00e3o de Restri\u00e7\u00f5es (CSPs) demonstram ser uma ferramenta poderosa para modelar e resolver uma ampla variedade de problemas que envolvem restri\u00e7\u00f5es complexas. Durante a an\u00e1lise e desenvolvimento de solu\u00e7\u00f5es baseadas em CSPs, observou-se a import\u00e2ncia da escolha adequada das estrat\u00e9gias de sele\u00e7\u00e3o de vari\u00e1veis e valores, visto que essas decis\u00f5es influenciam diretamente a efici\u00eancia e a viabilidade da resolu\u00e7\u00e3o. Al\u00e9m disso, as t\u00e9cnicas de propaga\u00e7\u00e3o de restri\u00e7\u00f5es mostraram ter um impacto significativo na redu\u00e7\u00e3o do espa\u00e7o de busca, permitindo identificar inconsist\u00eancias precocemente e, assim, acelerar o processo de resolu\u00e7\u00e3o. Tamb\u00e9m foi poss\u00edvel perceber que diferentes algoritmos apresentam desempenhos distintos dependendo do contexto e da estrutura do problema, o que refor\u00e7a a necessidade de uma an\u00e1lise criteriosa para a sele\u00e7\u00e3o do m\u00e9todo mais apropriado.</p> <p>Entre as contribui\u00e7\u00f5es desenvolvidas ao longo do projeto, destacam-se a implementa\u00e7\u00e3o de m\u00faltiplas estrat\u00e9gias de resolu\u00e7\u00e3o, a realiza\u00e7\u00e3o de uma an\u00e1lise comparativa de desempenho entre essas estrat\u00e9gias e a adapta\u00e7\u00e3o de abordagens espec\u00edficas para problemas cl\u00e1ssicos, como o Sudoku, demonstrando a flexibilidade e aplicabilidade dos CSPs em cen\u00e1rios diversos.</p>"},{"location":"portifolio-3/#referencias","title":"Refer\u00eancias","text":"<ol> <li>Russell, S., &amp; Norvig, P. (2020). Artificial Intelligence: A Modern Approach (4\u00aa ed.). Pearson.</li> <li>Dechter, R. (2003). Constraint Processing. Morgan Kaufmann.</li> <li>Kumar, V. (1992). Algorithms for Constraint Satisfaction Problems: A Survey. AI Magazine, 13(1), 32\u201344.</li> <li>Mackworth, A. K. (1977). Consistency in networks of relations. Artificial Intelligence, 8(1), 99\u2013118.</li> <li>Haralick, R. M., &amp; Elliott, G. L. (1980). Increasing tree search efficiency for constraint satisfaction problems. Artificial Intelligence, 14(3), 263\u2013313.</li> <li>Bessiere, C. (2006). Constraint propagation. In Handbook of Constraint Programming, Elsevier, 29\u201383.</li> <li>Apt, K. R. (2003). Principles of Constraint Programming. Cambridge University Press.</li> <li>Rossi, F., van Beek, P., &amp; Walsh, T. (Eds.). (2006). Handbook of Constraint Programming. Elsevier.</li> </ol>"}]}