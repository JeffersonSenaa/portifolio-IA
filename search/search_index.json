{"config":{"lang":["pt"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Portf\u00f3lio de Intelig\u00eancia Artificial","text":"<p>Este reposit\u00f3rio apresenta os portf\u00f3lios desenvolvidos durante a disciplina de Intelig\u00eancia Artificial, no curso de Engenharia de Software da Universidade de Bras\u00edlia.</p> <p>Baseado nos princ\u00edpios pedag\u00f3gicos de Benigna Maria de Freitas Villas Boas (2008), este portf\u00f3lio \u00e9 uma cole\u00e7\u00e3o comentada e reflexiva de conte\u00fados, conceitos, algoritmos e an\u00e1lises voltados \u00e0 Intelig\u00eancia Artificial, elaboradas ao longo da disciplina. \u00c9 mais do que uma simples reuni\u00e3o de conte\u00fados, o portf\u00f3lio \u00e9 uma ferramenta de aprendizagem ativa, autoavalia\u00e7\u00e3o e demonstra\u00e7\u00e3o de compet\u00eancias.</p>"},{"location":"#objetivos-do-portfolio","title":"Objetivos do Portf\u00f3lio","text":"<ul> <li>Demonstrar habilidades, compet\u00eancias e valores aprendidos ao longo dos estudos da disciplina;</li> <li>Refletir sobre os conte\u00fados trabalhados em sala de aula e fora dela;</li> <li>Explicar conceitos com autoria pr\u00f3pria, a partir das aulas, pesquisas e estudos individuais;</li> <li>Servir como instrumento de avalia\u00e7\u00e3o formativa pelo professor;</li> <li>Organizar produ\u00e7\u00f5es autorais, como textos, c\u00f3digos e projetos, com an\u00e1lise cr\u00edtica e contextualiza\u00e7\u00e3o.</li> </ul>"},{"location":"#estrutura-dos-topicos","title":"Estrutura dos T\u00f3picos","text":"<p>Os temas do portif\u00f3lio foram estruturados segundo os seguintes elementos:</p> <ol> <li>Introdu\u00e7\u00e3o ao Conte\u00fado </li> <li>Apresenta\u00e7\u00e3o da import\u00e2ncia do tema no contexto socioecon\u00f4mico, pol\u00edtico e tecnol\u00f3gico.</li> <li>Explora\u00e7\u00e3o e An\u00e1lise Cr\u00edtica </li> <li>Organiza\u00e7\u00e3o dos conceitos, com materiais pesquisados, referenciados e comentados.</li> <li>Problemas, Projetos e Aplica\u00e7\u00f5es </li> <li>Proposi\u00e7\u00e3o de exerc\u00edcios, problemas ou projetos autorais com solu\u00e7\u00f5es desenvolvidas e comentadas.</li> <li>Conclus\u00e3o </li> <li>Reflex\u00e3o sobre vantagens, limita\u00e7\u00f5es e principais aprendizados do t\u00f3pico.</li> </ol>"},{"location":"#capitulos-do-portifolio","title":"Cap\u00edtulos do Portif\u00f3lio","text":"<ol> <li>Introdu\u00e7\u00e3o \u00e0 Intelig\u00eancia Artificial</li> <li>Hist\u00f3rico, estado da arte, benef\u00edcios, riscos, agentes inteligentes, ambientes e racionalidade.</li> <li>Resolu\u00e7\u00e3o de Problemas por Busca</li> <li>Busca cega, informada e em ambientes complexos com algoritmos implementados em Python.</li> <li>Problemas de Satisfa\u00e7\u00e3o de Restri\u00e7\u00f5es</li> <li>Modelagem e resolu\u00e7\u00e3o de CSPs (Constraint Satisfaction Problems).</li> <li>Agentes L\u00f3gicos</li> <li>Representa\u00e7\u00e3o do conhecimento e infer\u00eancia por meio da l\u00f3gica proposicional e de predicados.</li> <li>Incerteza e Redes Bayesianas</li> <li>Probabilidade, infer\u00eancia bayesiana, filtros de Kalman e racioc\u00ednio probabil\u00edstico ao longo do tempo.</li> <li>Aprendizado de M\u00e1quina</li> <li>Fundamentos do aprendizado supervisionado, n\u00e3o supervisionado e suas aplica\u00e7\u00f5es pr\u00e1ticas.</li> </ol>"},{"location":"#tecnologias-e-ferramentas-utilizadas","title":"Tecnologias e Ferramentas Utilizadas","text":"<ul> <li>Python \u2013 Implementa\u00e7\u00e3o dos algoritmos</li> <li>MkDocs \u2013 Estrutura e navega\u00e7\u00e3o do portf\u00f3lio</li> <li>MkDocs Material \u2013 Tema visual moderno</li> <li>Jupyter Notebooks \u2013 C\u00f3digos interativos e an\u00e1lises (quando aplic\u00e1vel)</li> </ul>"},{"location":"#formato-de-apresentacao","title":"Formato de Apresenta\u00e7\u00e3o","text":"<p>Este portf\u00f3lio utiliza o formato de relat\u00f3rio estruturado com navega\u00e7\u00e3o digital, utilizando o MkDocs. Outras formas, como fichamento, mapa mental ou v\u00eddeo, poder\u00e3o ser adicionadas conforme a necessidade.</p> <p>Todos os materiais s\u00e3o referenciados e comentados, em conformidade com os crit\u00e9rios de avalia\u00e7\u00e3o da disciplina.</p>"},{"location":"#autor","title":"Autor","text":"<p>Jefferson Sena LinkedIn | GitHub  Estudante de Engenharia de Software - Universidade de Bras\u00edlia (UnB) Reposit\u00f3rio acad\u00eamico desenvolvido para a disciplina de Intelig\u00eancia Artificial  </p>"},{"location":"#licenca","title":"Licen\u00e7a","text":"<p>Este material \u00e9 disponibilizado sob a Licen\u00e7a MIT. Uso educacional incentivado.</p> <p>\u201cO portf\u00f3lio \u00e9 um instrumento de avalia\u00e7\u00e3o e reflex\u00e3o que permite que o estudante se reconhe\u00e7a em sua pr\u00f3pria trajet\u00f3ria de aprendizagem.\u201d \u2014 Benigna Maria de Freitas Villas Boas (2008)</p>"},{"location":"portifolio-2/","title":"Portifolio 2","text":""},{"location":"portifolio-2/#algoritmo-de-busca-cega","title":"Algoritmo de busca cega;","text":""},{"location":"portifolio-2/#random-search","title":"Random Search","text":"Python<pre><code>import random\ndef random_search(goal, domain):\nattempts = 0\nwhile True:\nguess = random.choice(domain)\nattempts += 1\nif guess == goal:\nreturn guess, attempts\n</code></pre>"},{"location":"portifolio-2/#o-que-sao-algoritmos-de-busca-cega","title":"O que s\u00e3o Algoritmos de Busca Cega?","text":"<p>Algoritmos de busca cega (ou busca n\u00e3o informada) s\u00e3o algoritmos que n\u00e3o utilizam nenhuma informa\u00e7\u00e3o adicional sobre o problema, como dist\u00e2ncia ou estimativas at\u00e9 o objetivo. Eles exploram o espa\u00e7o de busca de forma sistem\u00e1tica e completa, sem levar em considera\u00e7\u00e3o a posi\u00e7\u00e3o da meta, sendo ent\u00e3o \u201ccegos\u201d quanto ao melhor caminho.</p>"},{"location":"portifolio-2/#origem","title":"Origem","text":"<ul> <li>Surgiram nos anos 1950-60, envolto aos primeiros trabalhos em Intelig\u00eancia Artificial simb\u00f3lica.</li> <li>Aplicados em resolu\u00e7\u00e3o autom\u00e1tica de problemas, como quebra-cabe\u00e7as, jogos simples e sistemas de infer\u00eancia l\u00f3gica.</li> <li>S\u00e3o os primeiros tipos de algoritmos de busca utilizados em IA, tendo ra\u00edzes na teoria de grafos e na teoria dos aut\u00f4matos.</li> </ul>"},{"location":"portifolio-2/#como-funcionam","title":"Como Funcionam?","text":"<p>Eles expandem os n\u00f3s do espa\u00e7o de estados de acordo com uma regra fixa, como:</p> <ul> <li>Em ordem de chegada (fila \u2013 busca em largura).</li> <li>Em ordem de profundidade (pilha \u2013 busca em profundidade).</li> <li>Com menor custo acumulado (busca de custo uniforme).</li> </ul> <p>Esses algoritmos, n\u00e3o sabem se est\u00e3o se aproximando da meta. Apenas tentam todos os caminhos poss\u00edveis dentro do contexto.</p>"},{"location":"portifolio-2/#contextos-de-aplicacao","title":"Contextos de Aplica\u00e7\u00e3o","text":"<p>Embora menos eficientes que os algoritmos informados, os algoritmos de busca cega ainda s\u00e3o \u00fateis quando:</p> <ul> <li>N\u00e3o h\u00e1 informa\u00e7\u00e3o heur\u00edstica confi\u00e1vel dispon\u00edvel.</li> <li>O espa\u00e7o de busca \u00e9 pequeno.</li> <li>\u00c9 necess\u00e1rio garantir que a solu\u00e7\u00e3o seja \u00f3tima ou completa, mesmo sem pistas.</li> </ul> <p>Exemplos de aplica\u00e7\u00f5es:</p> <ul> <li>Solu\u00e7\u00f5es para problemas cl\u00e1ssicos de IA como o problema das torres de Han\u00f3i, quebra-cabe\u00e7as 8-puzzle.</li> <li>Sistemas educacionais, para ensinar l\u00f3gica de busca.</li> <li>Diagn\u00f3stico automatizado onde a heur\u00edstica n\u00e3o \u00e9 clara.</li> <li>Planejamento de a\u00e7\u00f5es simples em jogos e agentes aut\u00f4nomos.</li> </ul>"},{"location":"portifolio-2/#importancia","title":"Import\u00e2ncia","text":"<ul> <li>S\u00e3o a base conceitual para algoritmos mais avan\u00e7ados.</li> <li>Garantem completude (encontram a solu\u00e7\u00e3o, se houver uma).</li> <li>Podem ser usados em qualquer tipo de problema, mesmo sem conhecimento do dom\u00ednio.</li> <li>S\u00e3o \u00fateis para compara\u00e7\u00e3o e benchmarking de novos algoritmos.</li> </ul>"},{"location":"portifolio-2/#1-busca-exaustiva-brute-force-search","title":"1. Busca Exaustiva (Brute-force Search)","text":"<ul> <li>Verifica todas as combina\u00e7\u00f5es poss\u00edveis at\u00e9 encontrar a solu\u00e7\u00e3o.</li> <li>Muito lento, mas simples e confi\u00e1vel.</li> <li>Usado quando o espa\u00e7o de busca \u00e9 pequeno ou para validar solu\u00e7\u00f5es.</li> </ul> Text Only<pre><code>def brute_force_search(problem):\n    for solution in problem.all_possible_solutions():\n        if problem.is_goal(solution):\n            return solution\n    return None\n#Aplicacao: Tentar todas as senhas poss\u00edveis de um cadeado.\n</code></pre>"},{"location":"portifolio-2/#2-backtracking","title":"2. Backtracking","text":"<ul> <li>T\u00e9cnica de busca recursiva que volta atr\u00e1s quando encontra um beco sem sa\u00edda.</li> <li>Muito usada em problemas de combina\u00e7\u00e3o e permuta\u00e7\u00e3o, como Sudoku e quebra-cabe\u00e7as.</li> </ul> Python<pre><code>def solve(problem, state):\nif problem.is_goal(state):\nreturn state\nfor move in problem.legal_moves(state):\nnext_state = problem.apply_move(state, move)\nresult = solve(problem, next_state)\nif result:\nreturn result\nreturn None\n#Aplicacao: Resolver o Sudoku ou labirintos.\n</code></pre>"},{"location":"portifolio-2/#3-iterative-deepening-search-ids","title":"3. Iterative Deepening Search (IDS)","text":"<ul> <li>Combina\u00e7\u00e3o de profundidade com garantia de completude.</li> <li>Executa v\u00e1rias buscas em profundidade com profundidade limitada que vai aumentando.</li> <li>Usa pouca mem\u00f3ria encontrando solu\u00e7\u00f5es \u00f3timas.</li> </ul>"},{"location":"portifolio-2/#aplicacao-sudoku-com-backtracking","title":"Aplica\u00e7\u00e3o: Sudoku com Backtracking","text":"<p>Imagine que voc\u00ea est\u00e1 resolvendo um Sudoku. Voc\u00ea n\u00e3o sabe qual n\u00famero colocar, ent\u00e3o tenta todos de 1 a 9 em uma c\u00e9lula vazia. Caso d\u00ea erro, voc\u00ea volta atr\u00e1s e tenta outro n\u00famero \u2014 esse \u00e9 o comportamento t\u00edpico da busca cega com backtracking.</p>"},{"location":"portifolio-2/#algoritmo-de-busca-informada","title":"Algoritmo de busca informada;","text":""},{"location":"portifolio-2/#algoritmo-de-simulated-annealing","title":"Algoritmo de Simulated Annealing","text":"Python<pre><code>import math\nimport random\ndef simulated_annealing(objective_function, domain, temp_initial, cooling_rate):\ncurrent = random.uniform(*domain)\ntemp = temp_initial\nwhile temp &gt; 1:\nneighbor = current + random.uniform(-1, 1)\nneighbor = max(min(neighbor, domain[1]), domain[0])\ncost_diff = objective_function(neighbor) - objective_function(current)\nif cost_diff &lt; 0 or math.exp(-cost_diff / temp) &gt; random.random():\ncurrent = neighbor\ntemp *= cooling_rate\nreturn current\n# Exemplo: minimizar a fun\u00e7\u00e3o f(x) = x^2\nresult = simulated_annealing(lambda x: x**2, domain=(-10, 10), temp_initial=100, cooling_rate=0.95)\nprint(f\"Solu\u00e7\u00e3o encontrada: {result}, f(x) = {result**2}\")\n#**Aplica\u00e7\u00e3o:** Otimizar de forma cont\u00ednua as fun\u00e7\u00f5es complexas com m\u00ednimos locais.\n</code></pre>"},{"location":"portifolio-2/#o-que-sao-algoritmos-de-busca-informada","title":"O que s\u00e3o Algoritmos de Busca Informada?","text":"<p>Algoritmos de busca informada, s\u00e3o algoritmos que utilizam informa\u00e7\u00f5es adicionais (heur\u00edsticas) sobre o problema para a tomada de decis\u00f5es mais inteligentes durante a busca por solu\u00e7\u00f5es. Tendem a ser mais eficientes do que algoritmos de busca cega (como BFS ou DFS) porque conseguem priorizar caminhos promissores e assim evitar explorar caminhos irrelevantes.</p>"},{"location":"portifolio-2/#origem_1","title":"Origem","text":"<ul> <li>Deriva\u00e7\u00f5es de pesquisas em ci\u00eancia da computa\u00e7\u00e3o e IA cl\u00e1ssica nas d\u00e9cadas de 1960 e 1970.</li> <li>Fortemente influenciados pelo trabalho de nomes como Alan Turing, John McCarthy e Marvin Minsky.</li> <li>Cresceram com os primeiros sistemas de planejamento autom\u00e1tico e resolu\u00e7\u00e3o de problemas em ambientes como jogos e sistemas especialistas.</li> </ul>"},{"location":"portifolio-2/#como-funcionam_1","title":"Como Funcionam?","text":"<p>Esses algoritmos usam uma fun\u00e7\u00e3o heur\u00edstica <code>h(n)</code> que estima o custo restante de um estado <code>n</code> at\u00e9 a solu\u00e7\u00e3o. Essa fun\u00e7\u00e3o:</p> <ul> <li>N\u00e3o precisa ser perfeita, apenas uma boa estimativa.</li> <li>Ajuda a escolher qual n\u00f3 explorar primeiro com base em qual parece mais promissor.</li> </ul>"},{"location":"portifolio-2/#contextos-de-aplicacao_1","title":"Contextos de Aplica\u00e7\u00e3o","text":"<ul> <li>Jogos de estrat\u00e9gia e tabuleiro (ex.: xadrez, damas, sudoku)</li> <li>Planejamento de rotas (ex.: GPS, log\u00edstica)</li> <li>Rob\u00f3tica (ex.: navega\u00e7\u00e3o de rob\u00f4s aut\u00f4nomos)</li> <li>Diagn\u00f3stico autom\u00e1tico e sistemas especialistas</li> <li>Solu\u00e7\u00f5es em tempo real para IA em videogames</li> <li>Assistentes de voz e NLP (em fases de planejamento de di\u00e1logo)</li> </ul>"},{"location":"portifolio-2/#importancia_1","title":"Import\u00e2ncia","text":"<ul> <li>Efici\u00eancia: Exploram menos n\u00f3s que as buscas cegas.</li> <li>Escalabilidade: Lidam melhor com espa\u00e7os de busca grandes.</li> <li>Adaptabilidade: A heur\u00edstica pode ser ajustada para diferentes dom\u00ednios.</li> <li>S\u00e3o a base para algoritmos como A, IDA, Beam Search e etc.</li> </ul>"},{"location":"portifolio-2/#exemplos-de-algoritmos-de-busca-informada","title":"Exemplos de Algoritmos de Busca Informada","text":""},{"location":"portifolio-2/#1-beam-search","title":"1. Beam Search","text":"<ul> <li>Explora apenas os <code>k</code> melhores caminhos em cada n\u00edvel da \u00e1rvore de busca, limitando o n\u00famero de n\u00f3s expandidos.</li> <li>Usado em NLP (ex: tradu\u00e7\u00e3o autom\u00e1tica), pois \u00e9 mais eficiente do que expandir todos os caminhos poss\u00edveis.</li> </ul> Python<pre><code>import heapq\ndef beam_search(start, goal, neighbors, heuristic, beam_width):\nbeam = [(heuristic(start, goal), start)]\nwhile beam:\nnew_beam = []\nfor _, node in beam:\nif node == goal:\nreturn node\nfor neighbor in neighbors(node):\ncost = heuristic(neighbor, goal)\nheapq.heappush(new_beam, (cost, neighbor))\nbeam = heapq.nsmallest(beam_width, new_beam)\nreturn None\n</code></pre>"},{"location":"portifolio-2/#2-iterative-deepening-a-ida","title":"2. Iterative Deepening A (IDA)","text":"<ul> <li>Combina a busca em profundidade com heur\u00edsticas.</li> <li>Utiliza limites crescentes baseados na fun\u00e7\u00e3o <code>f(n) = g(n) + h(n)</code>.</li> </ul>"},{"location":"portifolio-2/#3-weighted-a","title":"3. Weighted A*","text":"<ul> <li>Variante do A*, mas multiplica a heur\u00edstica por um fator <code>w</code>:<ul> <li><code>f(n) = g(n) + w * h(n)</code></li> </ul> </li> <li>Com <code>w &gt; 1</code>, torna-se mais r\u00e1pido, mas menos preciso.</li> <li>Usado quando o tempo \u00e9 mais importante que a perfei\u00e7\u00e3o (ex: jogos ou rob\u00f4s em tempo real).</li> </ul>"},{"location":"portifolio-2/#exemplo-de-aplicacao-planejamento-de-rota-com-beam-search","title":"Exemplo de Aplica\u00e7\u00e3o: Planejamento de Rota com Beam Search","text":"<p>Imagine um rob\u00f4 de limpeza que decida o caminho mais eficiente at\u00e9 um ponto para recarregar. O mapa da casa \u00e9 representado como um grafo. O algoritmo usa a dist\u00e2ncia euclidiana como heur\u00edstica decidindo quais caminhos explorar primeiro, evitando paredes e obst\u00e1culos.</p>"},{"location":"portifolio-2/#algoritmo-de-busca-em-ambientes-complexos-gradient-descent-ou-hill-climbing","title":"Algoritmo de busca em ambientes complexos (Gradient Descent ou Hill Climbing)","text":""},{"location":"portifolio-2/#ambiente-complexo-algoritmo-de-gradiente-descendente","title":"Ambiente Complexo \u2014 Algoritmo de Gradiente Descendente","text":"Python<pre><code>def gradient_descent(derivative_func, start, learning_rate, n_iterations):\nx = start\nfor _ in range(n_iterations):\ngrad = derivative_func(x)\nx = x - learning_rate * grad\nreturn x\n# Exemplo: minimizar f(x) = x^2 \u2192 f'(x) = 2x\nminimum = gradient_descent(lambda x: 2*x, start=10.0, learning_rate=0.1, n_iterations=100)\nprint(f\"M\u00ednimo encontrado: x = {minimum}, f(x) = {minimum**2}\")\n</code></pre>"},{"location":"portifolio-2/#o-que-sao-algoritmos-de-busca-em-ambientes-complexos","title":"O que s\u00e3o Algoritmos de Busca em Ambientes Complexos?","text":"<p>S\u00e3o algoritmos usados quando o espa\u00e7o de busca \u00e9 muito grande, cont\u00ednuo ou din\u00e2mico, o que torna invi\u00e1vel testar todas as solu\u00e7\u00f5es poss\u00edveis. Eles buscam melhorar uma solu\u00e7\u00e3o progressivamente, explorando os arredores de uma solu\u00e7\u00e3o atual com base em algum crit\u00e9rio de melhoria.</p>"},{"location":"portifolio-2/#principais-tipos","title":"Principais Tipos","text":""},{"location":"portifolio-2/#1-gradient-descent-descida-do-gradiente","title":"1. Gradient Descent (Descida do Gradiente)","text":"<ul> <li>Tipo: Algoritmo de otimiza\u00e7\u00e3o cont\u00ednua.</li> <li>Utiliza\u00e7\u00e3o: A fun\u00e7\u00e3o objetivo \u00e9 diferenci\u00e1vel (ou seja, podemos calcular sua derivada).</li> <li>Ideia: Dado um ponto inicial, move-se na dire\u00e7\u00e3o do gradiente negativo da fun\u00e7\u00e3o, que \u00e9 a dire\u00e7\u00e3o de maior \"decl\u00ednio\" da fun\u00e7\u00e3o.</li> </ul>"},{"location":"portifolio-2/#como-funciona","title":"Como funciona:","text":"<ol> <li>Escolhe-se uma solu\u00e7\u00e3o inicial (ex: peso de um modelo).</li> <li>Calcula-se o gradiente (a inclina\u00e7\u00e3o) da fun\u00e7\u00e3o no ponto atual.</li> <li>Move-se na dire\u00e7\u00e3o oposta ao gradiente.</li> <li>Repete-se o processo at\u00e9 atingir um m\u00ednimo local ou global.</li> </ol>"},{"location":"portifolio-2/#formula-basica-x-x-fx","title":"F\u00f3rmula b\u00e1sica:   x = x - \u03b1 * \u2207f(x)","text":""},{"location":"portifolio-2/#2-busca-local-hill-climbing-simulated-annealing-etc","title":"2. Busca Local (Hill Climbing, Simulated Annealing, etc.)","text":"<ul> <li>Tipo: Heur\u00edsticas de otimiza\u00e7\u00e3o baseadas em melhorar uma solu\u00e7\u00e3o atual.</li> <li>Diferente do Gradient Descent: N\u00e3o depende de derivadas, funciona com fun\u00e7\u00f5es n\u00e3o cont\u00ednuas.</li> <li>Exemplo relevante: Simulated Annealing, que permite aceitar piores solu\u00e7\u00f5es com alguma probabilidade para escapar de m\u00ednimos locais.</li> </ul>"},{"location":"portifolio-2/#origem-e-contexto-historico","title":"Origem e Contexto Hist\u00f3rico","text":"<ul> <li>O Gradient Descent surgiu no contexto do c\u00e1lculo multivariado e foi adaptado para problemas de IA a partir da d\u00e9cada de 1950.</li> <li>Tornou-se extremamente popular na aprendizagem de m\u00e1quina com o surgimento das redes neurais.</li> <li>M\u00e9todos de busca local t\u00eam origem em t\u00e9cnicas de otimiza\u00e7\u00e3o cl\u00e1ssica, mas evolu\u00edram para lidar com problemas n\u00e3o determin\u00edsticos e estoc\u00e1sticos em IA.</li> </ul>"},{"location":"portifolio-2/#aplicacoes-na-inteligencia-artificial","title":"Aplica\u00e7\u00f5es na Intelig\u00eancia Artificial","text":""},{"location":"portifolio-2/#gradient-descent","title":"Gradient Descent:","text":"<ul> <li>Aprendizado de m\u00e1quina: Treinamento de redes neurais profundas, regress\u00e3o log\u00edstica, SVM, etc.</li> <li>Redu\u00e7\u00e3o de erro: Minimiza uma fun\u00e7\u00e3o de custo, como erro quadr\u00e1tico m\u00e9dio (MSE).</li> <li>Modelos probabil\u00edsticos: Ajuste de par\u00e2metros em modelos como Naive Bayes ou HMM.</li> </ul>"},{"location":"portifolio-2/#outros-algoritmos-de-busca-local","title":"Outros algoritmos de busca local:","text":"<ul> <li>Otimiza\u00e7\u00e3o de hiperpar\u00e2metros (ex: n\u00famero de neur\u00f4nios, taxa de aprendizado).</li> <li>Planejamento de a\u00e7\u00f5es em IA (com Simulated Annealing ou algoritmos estoc\u00e1sticos).</li> <li>IA em jogos e rob\u00f3tica, onde o ambiente muda e n\u00e3o h\u00e1 tempo para uma busca exaustiva.</li> </ul>"},{"location":"portifolio-2/#exemplos-de-algoritmos","title":"Exemplos de Algoritmos","text":""},{"location":"portifolio-2/#1-gradient-descent","title":"1. Gradient Descent","text":"Python<pre><code># Minimizar a fun\u00e7\u00e3o f(x) = (x - 5)**2\ndef f(x):\nreturn (x - 5)**2\ndef grad_f(x):\nreturn 2 * (x - 5)\nx = 0  # ponto inicial\nlr = 0.1  # taxa de aprendizado\nfor _ in range(100):\nx -= lr * grad_f(x)\nprint(f\"M\u00ednimo encontrado em x = {x}\")\n#Converge para x = 5, que \u00e9 o m\u00ednimo global da fun\u00e7\u00e3o.\n</code></pre>"},{"location":"portifolio-2/#2-simulated-annealing-busca-local-com-perturbacoes","title":"2. Simulated Annealing (busca local com perturba\u00e7\u00f5es)","text":"Python<pre><code>import math\nimport random\ndef objective(x):\nreturn (x - 3)**2 + 2\nx = random.uniform(-10, 10)\nT = 1.0\nT_min = 0.0001\nalpha = 0.9\nwhile T &gt; T_min:\nnew_x = x + random.uniform(-1, 1)\ndelta = objective(new_x) - objective(x)\nif delta &lt; 0 or random.random() &lt; math.exp(-delta / T):\nx = new_x\nT *= alpha\nprint(f\"Melhor solu\u00e7\u00e3o encontrada: x = {x}\")\n</code></pre>"},{"location":"portifolio-2/#importancia-dos-algoritmos-em-ambientes-complexos","title":"Import\u00e2ncia dos Algoritmos em Ambientes Complexos","text":"<ul> <li>S\u00e3o fundamentais para resolver problemas onde:<ul> <li>O espa\u00e7o de busca \u00e9 enorme ou cont\u00ednuo.</li> <li>A solu\u00e7\u00e3o exata n\u00e3o \u00e9 conhecida.</li> <li>\u00c9 necess\u00e1rio tempo real ou adapta\u00e7\u00e3o constante (ex: IA em jogos, carros aut\u00f4nomos).</li> </ul> </li> <li>Est\u00e3o na base de muitos avan\u00e7os modernos em deep learning e intelig\u00eancia artificial.</li> </ul> Conceito Gradient Descent Busca Local Precisa de derivada? Sim N\u00e3o Tipo de fun\u00e7\u00e3o Cont\u00ednua Arbitr\u00e1ria Exemplo Treinamento de rede neural Planejamento em IA Vantagem Converg\u00eancia r\u00e1pida Vers\u00e1til para ambientes estoc\u00e1sticos"},{"location":"portifolio-2/#algoritmo-genetico","title":"Algoritmo gen\u00e9tico","text":"Python<pre><code>import random\ndef fitness(x):\nreturn -1 * (x - 3)**2 + 9  # M\u00e1ximo em x = 3\ndef genetic_algorithm(population, generations, mutation_rate=0.1):\nfor _ in range(generations):\npopulation.sort(key=fitness, reverse=True)\nnext_gen = population[:2]  # elitismo\nwhile len(next_gen) &lt; len(population):\np1, p2 = random.sample(population[:4], 2)\nchild = (p1 + p2) / 2\nif random.random() &lt; mutation_rate:\nchild += random.uniform(-1, 1)\nnext_gen.append(child)\npopulation = next_gen\nbest = max(population, key=fitness)\nreturn best\n# Exemplo: encontrar o m\u00e1ximo da fun\u00e7\u00e3o - (x-3)^2 + 9\ninitial_pop = [random.uniform(0, 6) for _ in range(6)]\nsolution = genetic_algorithm(initial_pop, generations=20)\nprint(f\"Solu\u00e7\u00e3o gen\u00e9tica: x = {solution}, f(x) = {fitness(solution)}\")\n</code></pre>"},{"location":"portifolio-2/#o-que-sao-algoritmos-geneticos","title":"O que s\u00e3o Algoritmos Gen\u00e9ticos?","text":"<p>Algoritmos Gen\u00e9ticos (AGs) s\u00e3o t\u00e9cnicas de otimiza\u00e7\u00e3o e busca inspiradas nos processos de sele\u00e7\u00e3o natural e evolu\u00e7\u00e3o biol\u00f3gica descritos por Charles Darwin. Eles pertencem \u00e0 categoria de algoritmos evolutivos, que usam conceitos como popula\u00e7\u00e3o, muta\u00e7\u00e3o, reprodu\u00e7\u00e3o e sele\u00e7\u00e3o para resolver problemas complexos.</p>"},{"location":"portifolio-2/#origem-dos-algoritmos-geneticos","title":"Origem dos Algoritmos Gen\u00e9ticos","text":"<ul> <li>Foram propostos por John Holland na d\u00e9cada de 1970, na Universidade de Michigan.</li> <li>Holland criou uma estrutura matem\u00e1tica para entender os mecanismos da evolu\u00e7\u00e3o natural e adapt\u00e1-los \u00e0 resolu\u00e7\u00e3o de problemas computacionais.</li> <li>Seu livro de 1975, \"Adaptation in Natural and Artificial Systems\", \u00e9 a base te\u00f3rica dos AGs.</li> </ul>"},{"location":"portifolio-2/#como-funcionam-os-algoritmos-geneticos","title":"Como Funcionam os Algoritmos Gen\u00e9ticos?","text":"<ol> <li>Inicializa\u00e7\u00e3o: Uma popula\u00e7\u00e3o inicial de solu\u00e7\u00f5es (chamadas de indiv\u00edduos ou cromossomos) \u00e9 gerada aleatoriamente.</li> <li>Avalia\u00e7\u00e3o (Fitness): Cada indiv\u00edduo \u00e9 avaliado por uma fun\u00e7\u00e3o de aptid\u00e3o (fitness function) que mede qu\u00e3o boa \u00e9 a solu\u00e7\u00e3o.</li> <li>Sele\u00e7\u00e3o: Indiv\u00edduos mais aptos t\u00eam mais chances de serem escolhidos para gerar descendentes.</li> <li>Crossover (Recombina\u00e7\u00e3o): Partes dos cromossomos dos pais s\u00e3o combinadas para criar novos indiv\u00edduos.</li> <li>Muta\u00e7\u00e3o: Pequenas altera\u00e7\u00f5es aleat\u00f3rias s\u00e3o feitas nos descendentes para manter diversidade gen\u00e9tica.</li> <li>Substitui\u00e7\u00e3o: Uma nova gera\u00e7\u00e3o substitui (total ou parcialmente) a antiga.</li> <li>Itera\u00e7\u00e3o: O processo se repete por v\u00e1rias gera\u00e7\u00f5es at\u00e9 que uma condi\u00e7\u00e3o de parada seja satisfeita (ex: n\u00famero m\u00e1ximo de gera\u00e7\u00f5es, solu\u00e7\u00e3o suficientemente boa, etc).</li> </ol>"},{"location":"portifolio-2/#contextos-de-aplicacao-dos-algoritmos-geneticos","title":"Contextos de Aplica\u00e7\u00e3o dos Algoritmos Gen\u00e9ticos","text":"<p>AGs s\u00e3o usados em problemas de otimiza\u00e7\u00e3o complexos, onde n\u00e3o h\u00e1 uma solu\u00e7\u00e3o exata vi\u00e1vel ou onde o espa\u00e7o de busca \u00e9 muito grande:</p>"},{"location":"portifolio-2/#exemplos-de-aplicacoes","title":"Exemplos de aplica\u00e7\u00f5es:","text":"<ul> <li>Otimiza\u00e7\u00e3o de rotas: problema do caixeiro viajante (TSP), roteamento de entregas.</li> <li>Agendamento: aloca\u00e7\u00e3o de tarefas em f\u00e1bricas ou escalas de funcion\u00e1rios.</li> <li>Design de redes neurais: otimiza\u00e7\u00e3o de hiperpar\u00e2metros de redes profundas.</li> <li>Engenharia: design de circuitos eletr\u00f4nicos, estruturas mec\u00e2nicas.</li> <li>Bioinform\u00e1tica: alinhamento de sequ\u00eancias gen\u00e9ticas, previs\u00e3o de estrutura de prote\u00ednas.</li> <li>Criptografia: quebra de cifras por tentativa evolutiva.</li> <li>Jogos e IA: criar NPCs adaptativos ou estrat\u00e9gias vencedoras.</li> </ul>"},{"location":"portifolio-2/#por-que-algoritmos-geneticos-sao-importantes","title":"Por que Algoritmos Gen\u00e9ticos s\u00e3o Importantes?","text":"<ul> <li>Robustez: Funcionam bem mesmo com fun\u00e7\u00f5es de custo n\u00e3o lineares, descont\u00ednuas ou com m\u00faltiplos \u00f3timos locais.</li> <li>Paralelismo natural: Por usar popula\u00e7\u00f5es, podem explorar v\u00e1rias solu\u00e7\u00f5es ao mesmo tempo.</li> <li>Generalidade: Podem ser aplicados a muitos tipos diferentes de problemas.</li> <li>N\u00e3o precisam de derivadas: Diferente do gradiente descendente, AGs n\u00e3o exigem fun\u00e7\u00f5es diferenci\u00e1veis.</li> </ul>"},{"location":"portifolio-2/#exemplos-de-algoritmos-geneticos-e-variantes","title":"Exemplos de Algoritmos Gen\u00e9ticos e Variantes","text":"<ol> <li>Algoritmo Gen\u00e9tico Cl\u00e1ssico (GA):<ul> <li>Baseado nos operadores b\u00e1sicos: sele\u00e7\u00e3o, crossover e muta\u00e7\u00e3o.</li> </ul> </li> <li>Algoritmo Gen\u00e9tico com Elitismo:<ul> <li>Garante que os melhores indiv\u00edduos de uma gera\u00e7\u00e3o sobrevivem \u00e0 pr\u00f3xima.</li> </ul> </li> <li>Algoritmos Gen\u00e9ticos Multiobjetivo (ex: NSGA-II):<ul> <li>Resolvem problemas com m\u00faltiplos crit\u00e9rios de otimiza\u00e7\u00e3o.</li> </ul> </li> <li>Algoritmos Evolutivos Diferenciais:<ul> <li>Variante que usa diferen\u00e7as entre solu\u00e7\u00f5es para gerar novas.</li> </ul> </li> <li>Algoritmos Gen\u00e9ticos com Codifica\u00e7\u00e3o Real:<ul> <li>Ao inv\u00e9s de bits, usam n\u00fameros reais (mais comum em otimiza\u00e7\u00e3o cont\u00ednua).</li> </ul> </li> </ol>"}]}